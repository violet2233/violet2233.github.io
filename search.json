[{"title":"ArchLinux+Hexo搭建个人博客","url":"/2021/11/07/ArchLinux-Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","content":"还没来得及写\n","tags":["Linux"]},{"title":"CSS学习笔记","url":"/2021/11/11/CSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"CSS学习笔记1.1 什么是CSSCascading Style Sheet 级联样式表。表现HTML或XHTML文件样式的计算机语言。包括对字体、颜色、边距、高度、宽度、背景图片、网页定位等设定。\n1.2 CSS发展史1996年 CSS1.0\n1998年 CSS2.0 div(块) + CSS ,HTML与CSS结构分离的思想，网页变得很简单\n2004年 CSS2.1 浮动、定位\n2010年 CSS3.0推出 圆角边框、动画、阴影….. 浏览器兼容性\n1.3 基本的语法\n语法\n选择器{\n​\t声明: 1;\n​\t声明: 2；\n​\t声明: 3;\n}\n每一个声明最好使用 ; 结尾\n\n优势\n\n内容和表现分离\n网页结构表现统一，可以实现复用\n样式十分的丰富\n利用SEO，容易被搜索引擎搜到\n\n\n\n/* CSS样式 */h1&#123;    color: red;&#125;\n\n&lt;!-- HTML --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;css/index.css&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;哈哈哈哈&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;\n\n1.4 CSS三种导入方式\n行内样式\n\n&lt;!-- 行内样式 --&gt;&lt;h1 style=&quot;color: green;&quot;&gt;直接在标签后面加上style&lt;/h1&gt;&lt;p style=&quot;color: red;&quot;&gt;style里面写样式&lt;/p&gt;\n\n\n内部样式\n\nCSS代码写在  的标签中\n\n&lt;style&gt;        /* 内部样式 */        h2&#123;            color: red;        &#125;    &lt;/style&gt;\n\n\n优点：方便在同页面中修改样式\n缺点：不利于在多页面间共享复用代码及维护，对内容与样式的分离也不够彻底引出外部样式表\n\n\n外部样式\nCSS代码保存在扩展名为.css的样式表中HTML文件引用扩展名为.css的样式表，有两种方式\n\n链接式（使用最多，建议使用）\n\n使用 标签链接外部样式表，  标签必须放在\n 标签中\n\n&lt;head&gt;&lt;!--  链接式  --&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot;&gt;&lt;/head&gt;\n\n导入式（影响网页加载，不建议用）\n&lt;!--  导入式  不建议使用，加载慢  --&gt;&lt;style type=&quot;text/css&quot;&gt;        @import url(css/index.css);    &lt;/style&gt;\n\n链接式与导入式的区别\n\n 标签是属于XHTML范畴的，@import是属于CSS2.1中特有的。\n使用 链接的CSS是客户端浏览网页时先将外部CSS文件加载到网页当中，然后再进行编译显示，所以这种情况下显示出来的网页与用户预期的效果一样，即使网速再慢也一样的效果。\n使用@import导入的CSS文件，客户端在浏览网页时是先将HTML结构呈现出来，再把外部CSS文件加载到网页当中，当然最终的效果也与使用 链接文件效果一样，只是当网速较慢时会先显示没有CSS统一布局的HTML网页，这样就会给用户很不好的感觉。这个也是现在目前大多少网站采用链接外部样式表的主要原因。\n由于@import是属于CSS2.1中特有的，因此对于不兼容CSS2.1的浏览器来说就是无效的。\n\n\n\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;!-- 外部样式 --&gt;    &lt;!--  导入式  不建议使用，加载慢  --&gt;    &lt;style type=&quot;text/css&quot;&gt;        @import url(css/index.css);    &lt;!--  链接式  --&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot;&gt;    &lt;style&gt;        /* 内部样式 */        h2&#123;            color: red;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 行内样式 --&gt;&lt;h1 style=&quot;color: green;&quot;&gt;不会吧&lt;/h1&gt;&lt;p style=&quot;color: red;&quot;&gt;啊这&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;\n\n\ncss样式优先级\n行内样式&gt;内部样式&gt;外部样式\n就近原则：越接近标签的样式优先级越高\n\n\n\n1.5 基本选择器\n标签选择器\n会选择到页面上所有这个标签的元素\n/* HTML作为选择器的名称*/&lt;h1&gt;…&lt;h6&gt;、&lt;p&gt;、&lt;img/&gt;\n\n类选择器\n.class：类名\n可以多个标签归类，是同一个class，可以复用\n&lt;!-- 一些特殊的实现效果，单纯使用标签选择器不能实现，从而引出类选择器 --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;类选择器&lt;/title&gt;    &lt;style type=&quot;text/css&quot;&gt;        .title&#123;            color: gray;            font-size: 35px;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 类选择器 --&gt;&lt;p class=&quot;title&quot;&gt;这是标题&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;\n\nid选择器\nID选择器的名称就是HTML中标签的ID名称，ID全局唯一 （同一个页面只能使用一次）\n不遵循就近原则，id选择器 &gt; 类选择器 &gt; 标签选择器\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;id选择器&lt;/title&gt;    &lt;style type=&quot;text/css&quot;&gt;    &lt;!-- id选择器 --&gt;        #title&#123;            color: deeppink;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- id选择器 --&gt;&lt;p id=&quot;title&quot;&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;\n\n1.6 高级选择器\n层次选择器\n\n后代选择器：在某个元素的后面\n后代选择器两个选择符之间必须要以空格隔开，中间不能有任何其他的符号插入\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;后代选择器&lt;/title&gt;    &lt;style type=&quot;text/css&quot;&gt;        body p &#123;            color: red;            font-weight: bold;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;h&lt;/p&gt;&lt;p&gt;e&lt;/p&gt;&lt;h1&gt;l&lt;/h1&gt;&lt;h2&gt;l&lt;/h2&gt;&lt;p&gt;o&lt;/p&gt;&lt;ul&gt;    &lt;li&gt;        &lt;p&gt;p1&lt;/p&gt;        &lt;p&gt;p2&lt;/p&gt;        &lt;p&gt;p3&lt;/p&gt;    &lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;\n\n子选择器：一代、儿子\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;子代选择器&lt;/title&gt;    &lt;style type=&quot;text/css&quot;&gt;        body &gt; p &#123;            color: red;            font-weight: bold;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;h&lt;/p&gt;&lt;p&gt;e&lt;/p&gt;&lt;h1&gt;l&lt;/h1&gt;&lt;h2&gt;l&lt;/h2&gt;&lt;ul&gt;    &lt;li&gt;        &lt;p&gt;p1&lt;/p&gt;        &lt;p&gt;p2&lt;/p&gt;        &lt;p&gt;p3&lt;/p&gt;    &lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;\n\n相邻兄弟选择器：同辈（只有一个，相邻向下）\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;相邻选择器&lt;/title&gt;    &lt;style type=&quot;text/css&quot;&gt;        .action + p &#123;            color: blue;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;h&lt;/p&gt;&lt;p&gt;e&lt;/p&gt;&lt;h1&gt;l&lt;/h1&gt;&lt;h2&gt;l&lt;/h2&gt;&lt;p&gt;o&lt;/p&gt;&lt;p&gt;你不能变色吧&lt;/p&gt;&lt;p class=&quot;action&quot;&gt;    一次就好&lt;/p&gt;&lt;p&gt;你应该变色吧&lt;/p&gt;&lt;ul&gt;    &lt;li&gt;        &lt;p&gt;p1&lt;/p&gt;        &lt;p&gt;p2&lt;/p&gt;        &lt;p&gt;p3&lt;/p&gt;    &lt;/li&gt;&lt;/ul&gt;&lt;p class=&quot;action&quot;&gt;两次也行&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;\n\n通用选择器：当前选中元素向下的所有兄弟元素\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;通用选择器&lt;/title&gt;    &lt;style type=&quot;text/css&quot;&gt;        .action ~ p &#123;            color: khaki;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;h&lt;/p&gt;&lt;p&gt;e&lt;/p&gt;&lt;h1&gt;l&lt;/h1&gt;&lt;h2&gt;l&lt;/h2&gt;&lt;p&gt;o&lt;/p&gt;&lt;p&gt;你不能变色吧&lt;/p&gt;&lt;p&gt;你也不能变色吧&lt;/p&gt;&lt;!-- 下面所有的p标签变色--&gt;&lt;p class=&quot;action&quot;&gt;    一次就好&lt;/p&gt;&lt;p&gt;你应该变色吧&lt;/p&gt;&lt;p&gt;你能变色吧&lt;/p&gt;&lt;p&gt;你能变色吧&lt;/p&gt;&lt;ul&gt;    &lt;li&gt;        &lt;p&gt;p1&lt;/p&gt;        &lt;p&gt;p2&lt;/p&gt;        &lt;p&gt;p3&lt;/p&gt;    &lt;/li&gt;&lt;/ul&gt;&lt;p class=&quot;action&quot;&gt;两次也行&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n结构伪类选择器\n\n属性选择器\n\n\n","tags":["学习笔记"]},{"title":"ArchLinux安装指南","url":"/2021/11/07/ArchLinux%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/","content":"我的配置\n\n1.ArchLinux基础安装1.1.1查看是否为UFEI启动ls /sys/firmware/efi/efivars\n\n输入上面的命令，显示的有东西就是UEFI启动\n\n如果出现ls: cannot access ‘&#x2F;sys&#x2F;firmware&#x2F;efi&#x2F;efivars’: No such file or directory则为BIOS引导\n1.1.2 连接网络\n有线网络直接插网线就行\n\n无线网操作如下\nfrkill unblock wifi \t#解锁无线网卡iwctl\t\t\t\t\t#执行iwctl命令device list         \t#列出设备名，比如无线网卡看到叫 wlan0station wlan0 scan  \t#扫描网络station wlan0 get-networks \t\t#列出网络 比如想连接YOUR-WIRELESS-NAME这个无线station wlan0 connect YOUR-WIRELESS-NAME #进行连接 输入密码即可exit                 \t#成功后exit退出ping www.baidu.com\t\t#测试网络有没有连接成功\n\n1.1.2.更新系统时钟timedatectl set-ntp true    #将系统时间与网络时间进行同步timedatectl status          #检查服务状态\n\n1.1.3分区我的硬盘是512G的固态硬盘，我打算设个三个分区\n\nEFI分区： &#x2F;efi  500M\n\n根目录：  &#x2F;       130G\n\n用户根目录： &#x2F;home    剩余全部分区\nlsblk                       #显示分区情况 找到你想安装的磁盘名称parted /dev/sda             #执行parted，进入交互式命令行，进行磁盘类型变更(parted)mktable             #输入mktableNew disk label type? gpt    #输入gpt 将磁盘类型转换为gpt 如磁盘有数据会警告，输入yes即可quit    \n\ncfdisk /dev/sdx #来执行分区操作,分配各个分区大小，类型fdisk -l \t\t#分区结束后， 复查磁盘情况\n\n\n\n\n图片仅供参考，分完之后选择Write，然后输入yes，就可以选择Quit退出了\n1.1.4格式化分区fdisk -l \t\t\t  #分区结束后，查看分好的磁盘\t\t#格式化分区mkfs.ext4 /dev/sda2   #将根目录格式化为ext4格式mkfs.ext4 /dev/sda3   #将home目录格式化为ext4格式mkfs.vfat /dev/sda1   #将根目录格式化为vfat格式\n\n\n5.挂载mount /dev/sda2\t/mntmkdir /mnt/home\t\t#创建home目录mount /dev/sda3 /mnt/home\t#挂载home目录mkdir /mnt/efi\t\t#创建efimount /dev/sda1\t/mnt/efi\t#挂载efi目录lsblk 查看挂载状态\n\n\n\n6.安装系统\n更换镜像源\nreflector --country China --age 24 --sort rate --protocol https --save /etc/pacman.d/mirrorlist\n\n安装必备基础包\npacstrap /mnt base base-devel linux linux-headers linux-firmware \n\n必备的功能性软件\npacstrap /mnt dhcpcd iwd vim bash-completion\n\n\n7.生成fstab文件genfstab -U /mnt &gt;&gt; /mnt/etc/fstab #生成fstab文件cat /mnt/etc/fstab\t\t#查看一下\n\n\n\n08.配置新系统1. 切换到刚安装好的系统arch-chroot /mnt\n\n2.设置时区ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime hwclock --systohc \t#同步硬件时钟\n\n3.设置locale本地化vim /etc/locale.gen  编辑本地化配置文件/zh_CN.UTF_8 #找到这行然后按键盘i进入编辑模式，去点前面的#。然后按键盘上的esc/en_US.UTF_8 #找到这行然后按键盘i进入编辑模式，去点前面的#。然后按键盘上的esc， 接着:wq保存退出echo &#x27;LANG=en_US.UTF-8&#x27; &gt; /etc/locale.conf\n\n\nlocale-gen #生成locale\n\n4.生成主机名vim /etc/hostname   #设置主机名\n\n然后输入你的主机名，我的是 arch\nvim /etc/hosts\t#设置hosts#接着输入下面的内容127.0.1.1\tlocalhost::1\t\t\tlocalhost127.0.1.1\tarch.localdomain\tarch\n\n输完建议 cat &#x2F;etc&#x2F;hosts 检查一下\n\n5.为root用户设置密码passwd root  #输密码的时候屏幕不会显示\n\n6.安装微码以及引导程序\n微码根据你的处理器品牌选择\n\npacman -S intel-ucode   #Intelpacman -S amd-ucode     #AMD\n\n\n安装引导程序\npacman -S grub efibootmgr   #grub是启动引导器，efibootmgr被 grub 脚本用来将启动项写入 NVRAM。grub-install --target=x86_64-efi --efi-directory=/efi --removable\n\n\n\n编辑grub文件\n\n\nvim /etc/default/grub\n\n​\t去掉GRUB_CMDLINE_LINUX_DEFAULT一行中最后的 quiet 参数，同时把 log l\tevel 的数值从 3 改成 5。这样是为了后续如果出现系统错误，方便排错。同\t时在同一行加入 nowatchdog 参数，这可以显著提高开关机速度。不会 vim \t的同学注意视频中的操作。\n\n最后生成 GRUB 所需的配置文件\ngrub-mkconfig -o /boot/grub/grub.cfg\n\n7.卸载分区exit                # 退回安装环境#umount -R  /mnt     # 卸载新分区reboot              # 重启\n\n现在一个无桌面环境的ArchLinux就安装好了。\n","tags":["Linux"]},{"title":"Hello World","url":"/2021/09/30/HelloWorld/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: [Deployment](\n","tags":["Hello World"]},{"title":"HTML学习笔记","url":"/2021/11/07/HTML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"根据B站狂神的HTML教程学习写的笔记！！！\n1.1 什么是HTML Hyper Text Markup Language（超文本标记语言），用来描述网页的。Web 浏览器的作用是读取 HTML 文档，并以网页的形式显示出它们。浏览器不会显示 HTML 标签，而是使用标签来解释页面的内容。HTML文档是由HTML元素定义的。HTML元素指的是开始标签到结束标签的所有代码\n\n1.2 W3C标准1.2.1 W3C\nWorld Wide Web Consortium（万维网联盟）\n\n成立于1994年，Web技术领域最权威具据影响力的国际中立性技术标准机构\n\nhttp://www.w3.org/\n​\n\n\n1.2.2 W3C标准概括\n结构化标准语言（HTMl、XML）\n表现标准语言（CSS）\n行为标准（DON、ECMAScript）\n\n1.3 网页基本信息1.3.1 网页基本信息&lt;!DOCTYPE html&gt; &lt;!-- 文档声明 --&gt;&lt;html lang=&quot;en&quot;&gt; &lt;!-- 表示文档的开始 --&gt;开始的标签&lt;head&gt;    &lt;!-- head文件存放文档基本的信息，不可见元素！ --&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;!-- 声明文档字符编码 --&gt;    &lt;meta&gt; name=&quot;keywords&quot; count=&quot;描述性信息&quot; &lt;!-- meta描述性标签。可以用来描述我们网站的一些信息--&gt;     &lt;title&gt;我的第一个网页&lt;/title&gt; &lt;!-- 声明文档标题 --&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- body存放网页可见内容 --&gt;&lt;/body&gt;&lt;/html&gt;\n\n1.4 网页基本标签1.4.1 网页基本标签1.4.1.标题标签&lt;h1&gt;一级标签&lt;/h1&gt;&lt;h2&gt;二级标签&lt;/h2&gt;&lt;h3&gt;三级标签&lt;/h3&gt;&lt;h4&gt;四级标签&lt;/h4&gt;&lt;h5&gt;五级标签&lt;/h5&gt;&lt;h6&gt;六级标签&lt;/h6&gt;\n\n结果：\n\n1.4.2 段落标签&lt;!-- 段落标签 --&gt;&lt;!-- 段落标签使用之前 --&gt;使用段落标签之前：两只老虎爱跳舞，小兔子乖乖拔萝卜，我和小鸭子学走路，童年是最美的礼物。小螺号呀嘀嘀地吹，我学海鸥展翅飞，不怕风雨不怕累，快快把本领都学会。&lt;hr/&gt;&lt;!-- 段落标签使用之后 --&gt;&lt;p&gt;使用段落标签之后：&lt;/p&gt;&lt;p&gt;两只老虎爱跳舞，小兔子乖乖拔萝卜，&lt;/p&gt;&lt;p&gt;我和小鸭子学走路，童年是最美的礼物。&lt;/p&gt;&lt;p&gt;小螺号呀嘀嘀地吹，我学海鸥展翅飞，：&lt;/p&gt;&lt;p&gt;不怕风雨不怕累，快快把本领都学会。&lt;/p&gt;\n\n结果\n使用之前\n\n使用之后\n\n1.4.3 换行标签&lt;!-- 换行标签 --&gt;换行标签 &lt;br/&gt;两只老虎爱跳舞，小兔子乖乖拔萝卜，&lt;br/&gt;我和小鸭子学走路，童年是最美的礼物。&lt;br/&gt;小螺号呀嘀嘀地吹，我学海鸥展翅飞，&lt;br/&gt;不怕风雨不怕累，快快把本领都学会。&lt;br/&gt;\n\n结果\n\n1.4.4 水平线标签&lt;!-- 水平线标签 --&gt;&lt;hr&gt;\n\n结果\n\n1.4.5 字体样式标签&lt;!-- 字体样式标签 --&gt;粗体：&lt;strong&gt;114514&lt;/strong&gt; &lt;br&gt;斜体：&lt;em&gt;114514&lt;/em&gt;\n\n结果\n\n1.4.6 特殊符号&lt;!-- 特殊符号 --&gt;空格：空&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;格 （不使用空格符号默认只能显示一个空格）&lt;!-- 不使用空格符号默认只能显示一个空格--&gt; &lt;br/&gt;大于号：&amp;gt; &lt;br/&gt;小于号：&amp;lt; &lt;br/&gt;版权符号：&amp;copy;版权符号 &lt;br/&gt;\n\n结果\n\n1.5 图像img标签\nsrc：图片地址，推荐使用相对路径\n绝对路径： 通常都是从盘符开始（网络资源除外），不推荐使用，不灵活。\n相对路径： 相对于当前文档自身目标文件所在的位置。\n\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;图片标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- img图片标签 -    src：图片路径        推荐使用相对路径 ../    alt:图片名字(必填)    title：悬停文字    width: 图片宽度    height: 图片高度--&gt;&lt;img src=&quot;../代码/resources/img/genshin.webp&quot; alt=&quot;Dio娜&quot; title=&quot;Dio娜&quot; width=&quot;300px&quot; height=&quot;300px&quot;&gt;&lt;/body&gt;&lt;/html&gt;\n\n1.6 链接标签1.6.1 a标签\nhref：必填，表示要跳转到哪个界面\n\ntarget&#x3D; 表示窗口在哪打开\n​\t\t\t_blank 在新标签中打开\n​\t\t\t_seif 从当前标签打开网页\n\n\n&lt;!-- 从一个新标签打开我的网页 --&gt;&lt;a href=&quot;1.我的第一个网页.html&quot;target=&quot;_blank&quot;&gt;点击我跳转页面1&lt;/a&gt;&lt;!--直接跳转到b站--&gt;&lt;a href=&quot;https://www.bilibili.com&quot;target=&quot;_self&quot;&gt;bilibili&lt;/a&gt;\n\n1.6.2 网页跳转嵌套图片在a标签跳转的基础上增加图片\n&lt;a href=&quot;1.我的第一个网页.html&quot;target=&quot;_blank&quot;&gt;    &lt;img src=&quot;../代码/resources/img/huaji.webp&quot; alt=&quot;photo&quot;&gt;&lt;/a&gt;\n\n1.6.3 锚链接\n跳转到顶部\n需要一个标记\n接着跳转的标记\n\n\n\n&lt;!--跳转到顶部的标记 --&gt;&lt;a id=&quot;top&quot;&gt;顶部&lt;/a&gt;&lt;!--普通的网页内容 --&gt;&lt;p&gt;        &lt;a href=&quot;1.我的第一个网页.html&quot;target=&quot;_blank&quot;&gt;        &lt;img src=&quot;../代码/resources/img/huaji.webp&quot; alt=&quot;photo&quot;&gt;    &lt;/a&gt; &lt;/p&gt;&lt;!-- 跳转到顶部--&gt;&lt;a href=&quot;#top&quot;&gt;回到顶部&lt;/a&gt;\n\n\n从一个界面跳转到另一个界面的指定地方\n在要跳转到的界面指定标记\n从第一个界面使用a标签跳转到之前指定的标记\n\n\n\n&lt;!-- 要跳转的地方指定标记 --&gt;&lt;a id=&quot;down&quot;&gt;底部&lt;/a&gt;\n\n&lt;!-- 跳转到刚刚指定的标记 --&gt;&lt;a href=&quot;4.链接标签.html#down&quot;&gt;跳转到链接标签的底部&lt;/a&gt;\n\n\n邮件链接\n直接在href里添加”mailto:你的邮箱”\n\n\n\n&lt;!-- 邮件链接 --&gt;&lt;p&gt;        &lt;a href=&quot;mailto:210853870@qq.com&quot;&gt;跳转我的邮箱&lt;/a&gt;&lt;/p&gt;\n\n\nqq推广\n打开qq推广官网：https://shang.qq.com/v3/index.html\nqq推广组件里选择自己要推广的样式\n复制qq推广提供的代码\n\n\n\n&lt;!-- qq推广 --&gt;    &lt;a href=&quot;http://wpa.qq.com/msgrd?v=3&amp;uin=210853870&amp;site=qq&amp;menu=yes&quot;target=&quot;_blank&quot;&gt;        &lt;img border=&quot;0&quot; src=&quot;http://wpa.qq.com/pa?p=2:210853870:53&quot; alt=&quot;加我领取小电影！！！&quot; title=&quot;加我领取小电影！！！！&quot;/&gt;    &lt;/a&gt;\n\n\n1.7 行内元素和块级元素1.7.1 行内元素常见的行内元素\n&lt;a href=&quot;&quot;&gt;&lt;/a&gt; //a链接&lt;em&gt;&lt;/em&gt; //斜体&lt;img src=&quot;&quot; alt=&quot;&quot;&gt; //向网页中嵌入一幅图像&lt;span&gt;&lt;/span&gt; //组合文档中的行内元素&lt;br&gt; //换行..........................\n\n\n\n\n每一个行内元素可以和别的行内元素共享一行，相邻的行内元素会排列在同一行里，直到一行排不下了，才会换行。 \n行内元素的高度、宽度、行高及顶部和底部边距不可设置。 \n元素的宽度就是它包含的文字或图片的宽度，不可改变\n\n1.7.2 块级元素常见的块级元素\n&lt;div&gt; &lt;/div&gt; //定义文档中的分区或节 &lt;p&gt;&lt;/p&gt;  //标签定义段落&lt;h1~h6&gt;  //标题标签&lt;hr&gt;  //水平线标签&lt;li&gt;&lt;/li&gt;   //标签定义列表项目&lt;ol&gt;&lt;/ol&gt;  //定义有序列表&lt;ul&gt;&lt;/ul&gt;  //定义无序列表&lt;td&gt;&lt;/td&gt;  //表格中的标准单元格&lt;tr&gt;&lt;/tr&gt;  //定义表格中的行&lt;th&gt;&lt;/th&gt;  //定义表头单元格................................\n\n\n\n\n每个块级元素都是独自占一行。 \n元素的高度、宽度、行高和边距都是可以设置的。　　 \n元素的宽度如果不设置的话，默认为父元素的宽度（父元素宽度100%）。\n\n1.8 列表1.8.1 有序列表&lt;!-- 有序列表     常用于表单 试卷中--&gt;&lt;ul&gt;    &lt;li&gt;Java&lt;/li&gt;    &lt;li&gt;Go&lt;/li&gt;    &lt;li&gt;Python&lt;/li&gt;    &lt;li&gt;C++&lt;/li&gt;&lt;/ul&gt;\n\n\n1.8.2 无序列表&lt;!-- 无序列表     常用于侧边栏、导航栏 --&gt;&lt;ol&gt;    &lt;li&gt;Java&lt;/li&gt;    &lt;li&gt;Go&lt;/li&gt;    &lt;li&gt;Python&lt;/li&gt;    &lt;li&gt;C++&lt;/li&gt;&lt;/ol&gt;\n\n\n1.8.3 自定义列表&lt;!-- 自定义列表     常用于网站底部的标签栏     dl: 自定列表标签     dt：列表标题     dt：列表内容--&gt;&lt;dl&gt;    &lt;dt&gt;科目&lt;/dt&gt;    &lt;dd&gt;Java&lt;/dd&gt;    &lt;dd&gt;Go&lt;/dd&gt;    &lt;dd&gt;Python&lt;/dd&gt;    &lt;dd&gt;C++&lt;/dd&gt;    &lt;dt&gt;城市&lt;/dt&gt;    &lt;dd&gt;北京&lt;/dd&gt;    &lt;dd&gt;上海&lt;/dd&gt;    &lt;dd&gt;广州&lt;/dd&gt;    &lt;dd&gt;深圳&lt;/dd&gt;&lt;/dl&gt;\n\n\n1.9 表格1.9.1 表格的基本使用&lt;!-- 表格     表格：table     行：tr     列：td     表格边框：border 单位为px--&gt;&lt;table border=&quot;1px&quot;&gt;    &lt;tr&gt;        &lt;td&gt;1-1&lt;/td&gt;        &lt;td&gt;1-2&lt;/td&gt;        &lt;td&gt;1-3&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;2-1&lt;/td&gt;        &lt;td&gt;2-2&lt;/td&gt;        &lt;td&gt;2-3&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;3-1&lt;/td&gt;        &lt;td&gt;3-2&lt;/td&gt;        &lt;td&gt;3-3&lt;/td&gt;    &lt;/tr&gt;\n\n\n1.9.2 列表的跨行合并的使用&lt;table border=&quot;1px&quot;&gt;    &lt;tr&gt;        &lt;!-- colspan 跨列--&gt;        &lt;td colspan=&quot;3&quot; align=&quot;center&quot;&gt;成绩表&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;!-- rowspan 跨行--&gt;        &lt;td rowspan=&quot;2&quot;&gt;张三&lt;/td&gt;        &lt;td&gt;Java&lt;/td&gt;        &lt;td&gt;50&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;Css&lt;/td&gt;        &lt;td&gt;100&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td rowspan=&quot;2&quot;&gt;李四&lt;/td&gt;        &lt;td&gt;Java&lt;/td&gt;        &lt;td&gt;100&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;Css&lt;/td&gt;        &lt;td&gt;80&lt;/td&gt;    &lt;/tr&gt;&lt;/table&gt;\n\n\n2.0 音频和视频2.0.1 音频和视频&lt;!-- 音频和视频      controls: 控制条     autoplay: 自动播放     muted: 谷歌浏览器无法自动播放得在加上muted--&gt;&lt;!-- 视频 --&gt;&lt;video muted src=&quot;https://www.bilibili.com/video/BV1x4411V75C?p=9&amp;t=314.1&quot; controls autoplay&gt;&lt;/video&gt;&lt;hr&gt;&lt;!-- 音频 --&gt;&lt;audio muted src=&quot;https://music.163.com/outchain/player?type=2&amp;id=1492276411&amp;auto=1&amp;height=66&quot; controls autoplay&gt;&lt;/audio&gt;\n\n\n2.1 页面结构分析2.1.1 页面结构分析\n\n\n元素名\n描述\n\n\n\nheader\n标题头部区域内容（用于页面或页面中的一块区域）\n\n\nfootder\n标记脚部区域的内筒（用于整个页面或页面的一块区域）\n\n\nsection\nweb页面中的一块独立区域\n\n\nacticle\n独立的文章内容\n\n\naside\n相关内容或应用\n\n\nnav\n导航类辅助内容\n\n\n2.2 iframe内联框架2.2.1 firame内联框架\n&lt;!-- iframe\t 网站里嵌入另一个网站     src: 地址     height：高度     width：宽度 --&gt;&lt;iframe src=&quot;https://bilibili.com&quot; frameborder=&quot;0&quot; width=&quot;1000px&quot; height=&quot;500px&quot;&gt;&lt;/iframe&gt;&lt;!-- --&gt;&lt;iframe src=&quot;&quot; frameborder=&quot;0&quot; width=&quot;1000px&quot; height=&quot;500px&quot; name=&quot;blog&quot;&gt;&lt;/iframe&gt;&lt;a href=&quot;https://violet2233.github.io&quot; target=&quot;blog&quot;&gt;点我跳转&lt;/a&gt;\n\n\n\n2.3 表单\n\n\n属性\n说明\n\n\n\ntype\n指定元素类型。text、password、checkbox、radio、 submit、reset、file、hidden、image和button，默认为textt\n\n\nselect\n下拉选择框\n\n\ntextarea\n文本域\n\n\nname\n指定表单元素的名称\n\n\nvalue\n元素的初始值。type为radio时必须指定一个值\n\n\nsize\n指定表单元素的初始宽度，当type为text或passwprd时，表单元素的大小以字符为单位。对于其他类型，宽度以像素为单位\n\n\nmaxlength\ntype为text或password时，输入的最大字符数\n\n\nchecked\ntype为radio或checkbox时，指定按钮是否被选中\n\n\n\n\n\n\n属性\n说明\n\n\n\nreadonly\n只读，不可修改\n\n\ndisable\n禁用\n\n\nhidden\n隐藏，看不见但是能提交\n\n\nid\n配合label的for属性增加鼠标可用性（点文字进入搜索框）\n\n\nplacehoder\n文本框内容为空的时候显示的内容\n\n\nrequired\n检测输入框是否为空\n\n\npatten\n正则表达式验证\n\n\n\n\n&lt;h4&gt;注册&lt;/h4&gt;    &lt;!-- form表单 --&gt;    &lt;!-- action：提交表单的位置，可以是网站，也可以是请求处理地址 --&gt;    &lt;!-- method：get/post 提交方式，                 post更安全一点，可怡传送大文件                 get提交可以从url中看到，所以不推荐使用 --&gt;&lt;form action=&quot;1.我的第一个网页.html&quot; method=&quot;post&quot;&gt;    &lt;p&gt;        &lt;!-- 文本输入框 --&gt;        &lt;!-- input type=&quot;text&quot;             value：初始值             size: 输入框的大小             maxlength: 最多输入的字符             readonly: 只读        --&gt;        用户：&lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;这是初始值&quot; size=&quot;30&quot; maxlength=&quot;8&quot; readonly&gt;    &lt;/p&gt;    &lt;p&gt;        &lt;!-- 密码框 --&gt;        &lt;!-- hidden：隐藏--&gt;        密码：&lt;input type=&quot;password&quot; name=&quot;password&quot; hidden&gt;    &lt;/p&gt;    &lt;p&gt;        &lt;!-- 单选框 --&gt;        &lt;!-- input type=&quot;radio&quot;             value: 单选框的值             name：表示组，当name不为同一组时，所有选项都能选。             checked: 默认选择的值             disabled: 禁用        --&gt;        性别：        &lt;input type=&quot;radio&quot; value=&quot;boy&quot; name=&quot;gender&quot; disabled&gt;男        &lt;input type=&quot;radio&quot; value=&quot;girl&quot; name=&quot;gender&quot; checked &gt;女    &lt;/p&gt;    &lt;p&gt;        &lt;!-- 多选框 --&gt;        爱好：        &lt;input type=&quot;checkbox&quot; value=&quot;sing&quot; name=&quot;hobby&quot; checked&gt;唱        &lt;input type=&quot;checkbox&quot; value=&quot;dance&quot; name=&quot;hobby&quot;&gt;跳        &lt;input type=&quot;checkbox&quot; value=&quot;rap&quot; name=&quot;hobby&quot;&gt;rap        &lt;input type=&quot;checkbox&quot; value=&quot;basketball&quot; name=&quot;hobby&quot;&gt;篮球    &lt;/p&gt;    &lt;p&gt;        &lt;!-- 下拉框 --&gt;        &lt;!-- select name=&quot;列表名称&quot;&gt;             selected 默认选择的值         --&gt;        国家：        &lt;select name=&quot;列表名称&quot;&gt;            &lt;option value=&quot;china&quot; selected&gt;中国&lt;/option&gt;            &lt;option value=&quot;us&quot;&gt;美国&lt;/option&gt;            &lt;option value=&quot;yindu&quot;&gt;印度&lt;/option&gt;            &lt;option value=&quot;canada&quot;&gt;加拿大&lt;/option&gt;        &lt;/select&gt;    &lt;/p&gt;    &lt;!-- 按钮 --&gt;    &lt;p&gt;        &lt;!-- 自定义按钮 --&gt;        &lt;input type=&quot;button&quot; value=&quot;点我变大&quot; name=&quot;btn1&quot;&gt;        &lt;!-- 图片按钮 --&gt;        &lt;input type=&quot;image&quot; src=&quot;resources/img/test.png&quot;        &lt;!-- 提交按钮 提交表单数据 --&gt;        &lt;input type=&quot;submit&quot; name=&quot;submit&quot;&gt;        &lt;!-- 重置按钮 清空表单数据--&gt;        &lt;input type=&quot;reset&quot; name=&quot;清空表单&quot;&gt;    &lt;/p&gt;    &lt;p&gt;        &lt;!-- 文本域 --&gt;        &lt;!-- &lt;textarea cols=&quot;30&quot; rows=&quot;10&quot;&gt;        cols：显示列数        rows：显示行数         --&gt;        反馈：        &lt;textarea name=&quot;&quot; id=&quot;&quot; cols=&quot;50&quot; rows=&quot;10&quot;&gt;文本域&lt;/textarea&gt;    &lt;/p&gt;    &lt;p&gt;        &lt;!-- 文件域 --&gt;        &lt;input type=&quot;file&quot; name=&quot;upload&quot;&gt;        &lt;input type=&quot;button&quot; name=&quot;upload&quot; value=&quot;上传按钮&quot;&gt;    &lt;/p&gt;    &lt;p&gt;        &lt;!-- 邮箱验证 --&gt;        邮箱：        &lt;input type=&quot;email&quot; name=&quot;email&quot; &gt;    &lt;/p&gt;    &lt;p&gt;        &lt;!-- URL --&gt;        URL：        &lt;input type=&quot;url&quot; name=&quot;url&quot;&gt;    &lt;/p&gt;    &lt;p&gt;        &lt;!--  数字 --&gt;        &lt;!-- min：最小值             max：最大值             step: 增加按钮改变的值        --&gt;        数字：        &lt;input type=&quot;number&quot; name=&quot;number&quot; min=&quot;1&quot; max=&quot;100&quot; step=&quot;10&quot;&gt;    &lt;/p&gt;    &lt;p&gt;        &lt;!-- 滑块 --&gt;        音量：        &lt;input type=&quot;range&quot; name=&quot;voice&quot; min=&quot;1&quot; max=&quot;100&quot; step=&quot;2&quot;&gt;    &lt;/p&gt;    &lt;p&gt;        &lt;!-- 搜索 --&gt;        搜索：        &lt;input type=&quot;search&quot; name=&quot;search&quot;&gt;    &lt;/p&gt;    &lt;p&gt;        &lt;!-- 增强鼠标可用性 --&gt;        &lt;!-- 点击旁边的文字就能进入输入框             for指向id        --&gt;        &lt;label for=&quot;mark&quot;&gt;增强鼠标可用性            &lt;input type=&quot;text&quot; id=&quot;mark&quot;&gt;        &lt;/label&gt;    &lt;/p&gt;    &lt;p&gt;        &lt;!-- 表单初级验证 --&gt;        &lt;!-- placeholder：当输入框没有内容时显示提示文字             required：判断内容是否为空             pattern: 正则表达式判断        --&gt;        表单初级验证：        &lt;input type=&quot;text&quot; placeholder=&quot;请输入&quot; required&gt;    &lt;/p&gt;&lt;/form&gt;\n\n\n2.4 总结\n","tags":["学习笔记"]},{"title":"JDBC学习笔记","url":"/2022/06/21/JDBC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"jdbc笔记1.jdbc 概述\n基本介绍\n\nJDBC为访问不同的数据库提供了统一的接口，为使用者屏蔽了细节问题。\nJava程序员使用JDBC,可以连接任何提供了JDBC驱动程序的数据库系统，从而完成对数据库的各种操作\n\n\njdbc基本连接步骤\n\n注册驱动 加载Driver类\n\n获取连接 得到Connection\n\n执行增删改查 发送SQL给mysql执行\n\n释放资源，关闭相关连接(从大到小，从里到外)\n\n\n\n第一个jdbc程序\n\n\npublic class Jdbc01 &#123;    public static void main(String[] args) &#123;        Connection connection = null;        Statement statement = null;        ResultSet resultSet = null;        try &#123;            //从配置文件里读取连接信息            Properties pr = new Properties();            pr.load(new FileInputStream(&quot;src\\\\jdbc.properties&quot;));            String url = pr.getProperty(&quot;url&quot;);            String user = pr.getProperty(&quot;user&quot;);            String password = pr.getProperty(&quot;password&quot;);            //获得连接            connection = DriverManager.getConnection(url,user,password);            //创建Statement用于执行sql语句            statement = connection.createStatement();            //执行sql语句            String sql = &quot;insert into actor values(null,&#x27;张三&#x27;,&#x27;男&#x27;,&#x27;2022-02-02&#x27;,&#x27;112&#x27;)&quot;;            int i = statement.executeUpdate(sql);            //返回结果            System.out.println(i == 1? &quot;成功&quot;:&quot;失败&quot;);        &#125; catch (SQLException | IOException e) &#123;            throw new RuntimeException(e);        &#125; finally &#123;            //无论执行是否成功都释放资源            try &#123;                if (statement != null)&#123;                    statement.close();                &#125;                if (connection != null)&#123;                    connection.close();                &#125;            &#125; catch (SQLException e) &#123;                throw new RuntimeException(e);            &#125;        &#125;    &#125;&#125;\n\n2.获取连接的五种方式\n方式一\n\n\n方式二\n\n\n方式三\n\n\n方式四\n\n\n方式五\n\n\n\n3.ResultSet结果集\n基本介绍\n\n表示数据库结果集的数据表，通常通过执行查询数据库的语句生成\nResultSeti对象保持一个光标指向其当前的数据行。最初，光标位于第一行之前\nnext方法将光标移动到下一行，并且由于在ResultSet对象中没有更多行时返回false,因此可以在while循环中使用循环来遍历结果集\n\n\n应用实例\npublic class Jdbc02 &#123;    public static void main(String[] args) &#123;        Connection connection = null;        Statement statement = null;        ResultSet resultSet = null;        try &#123;            Properties pr = new Properties();            pr.load(new FileInputStream(&quot;src\\\\jdbc.properties&quot;));            String url = pr.getProperty(&quot;url&quot;);            String user = pr.getProperty(&quot;user&quot;);            String password = pr.getProperty(&quot;password&quot;);;            //获取连接            connection = DriverManager.getConnection(url, user, password);            //获取Statement对象            statement = connection.createStatement();            //执行sql语句            String sql = &quot;select * from actor&quot;;            resultSet = statement.executeQuery(sql);            //遍历resultSet结果集            while(resultSet.next()) &#123;                //getString 可以是下标，也可以是列名                //也可以是getInt getDouble......                int id = resultSet.getInt(&quot;id&quot;);                String name = resultSet.getString(&quot;name&quot;);                String sex = resultSet.getString(&quot;sex&quot;);                Date date = resultSet.getDate(&quot;borndate&quot;);                System.out.println(id + &quot;\\t&quot; + name + &quot;\\t&quot; + sex + &quot;\\t&quot; + date);            &#125;        &#125; catch (SQLException | IOException e) &#123;            throw new RuntimeException(e);        &#125; finally &#123;            try &#123;                //释放资源                if (resultSet != null)&#123;                    resultSet.close();                &#125;                if (statement != null)&#123;                    statement.close();                &#125;                if (connection != null)&#123;                    connection.close();                &#125;            &#125; catch (SQLException e) &#123;                throw new RuntimeException(e);            &#125;        &#125;    &#125;&#125;\n\n4.Statement\n基本介绍\n\nStatementi对象用于执行静态SQL语句并返回其生成的结果的对象\n在连接建立后，需要对数据库进行访问，执行命名或是SQL语句，可以通过Statement[存在SQL注入]、 PreparedStatement[预处理]、CallableStatement[存储过程]\nStatement对象执行SQL语句，存在SQL注入风险SQL Injection\nSQL注入是利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据中注入非法的SQL语句段或命令，恶意攻击数据库。sql injection.sql\n要防范SQL注入，只要用PreparedStatement(从Statement扩展而来)取代Statement就可以了，一会老师用java演示下.\n\n\n模拟用户登录引出sql注入\nSQL注入：用户输入的语句中含有sql关键字，并且这些关键字参与了sql语句的编译过程导致达到sql注入\npublic class UserLogin &#123;    public static void main(String[] args) throws Exception &#123;        //数据表已经准备好了 db03--&gt;user-login        //初始化界面        //要返回用户输入的账号和密码        Map&lt;String, String&gt; userLoginInfo = initUI();        //验证用户名和密码        boolean loginSuccess = login(userLoginInfo);        /**         * 请输入账号: sdsa         * 请输入密码：sdsa &#x27; or &#x27;1&#x27; = &#x27;1         * 登录成功         *         * sql注入。。。。。         * 用户输入的语句中含有sql关键字，并且这些关键字参与了sql语句的编译过程         * 导致达到sql注入         */        //返回结果        System.out.println(loginSuccess ? &quot;登录成功&quot; : &quot;登录失败&quot;);    &#125;    /**     * @param userLoginInfo     * @return 判断的结果     * @Description 判断账号密码是否正确     */    private static boolean login(Map&lt;String, String&gt; userLoginInfo) throws Exception &#123;        boolean loginSuccess = false;        //用户信息        String userName = userLoginInfo.get(&quot;loginName&quot;);        String userPwd = userLoginInfo.get(&quot;loginPwd&quot;);        //jdbc        //获取连接        Connection connection = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/db03&quot;, &quot;root&quot;, &quot;abcd1234&quot;);        //创建statement对象        Statement statement = connection.createStatement();        //执行sql语句        String sql = &quot;select * from `user-login` where loginName = &#x27;&quot; + userName + &quot;&#x27; and loginPwd = &#x27;&quot; + userPwd + &quot;&#x27;&quot;;        ResultSet resultSet = statement.executeQuery(sql);        //返回结果        if (resultSet.next()) &#123;            loginSuccess = true;        &#125;        //释放资源        if (statement != null) &#123;            statement.close();        &#125;        if (connection != null) &#123;            connection.close();        &#125;        return loginSuccess;    &#125;    /**     * @return 返回用户登录的账号密码     * @Description 初始化登录界面     */    private static Map&lt;String, String&gt; initUI() &#123;        Scanner sc = new Scanner(System.in);        System.out.println(&quot;请输入账号：&quot;);        String loginName = sc.nextLine();        System.out.println(&quot;请输入密码：&quot;);        String loginPwd = sc.nextLine();        HashMap&lt;String, String&gt; userLoginInfo = new HashMap&lt;&gt;();        userLoginInfo.put(&quot;loginName&quot;, loginName);        userLoginInfo.put(&quot;loginPwd&quot;, loginPwd);        return userLoginInfo;    &#125;&#125;\n\n要解决上面的问题需要使用PrepareStatement\n\n\n5.PreparedStatement\n基本介绍\n\nPreparedStatement继承了Statement接口\nPreparedStatement执行的SQL语句中的参数用问号(？)来表示，调PreparedStatement对象的setXxx()方法来设置这些参数.setXxx0方法有两个参数，第一个参数是要设置的SQL语句中的参数的索引（从1开始），第二个是设置的SQL语句中的参数的值\n调用executeQuery0,返回ResultSet对象\n调用executeUpdate0:执行更新，包括增、删、修改\n\n\n解决sql注入\n\n只要用户提供的信息不参与SQ江语句的编译过程，问题就解决了。即使用户提供的信息中含有SQ语句的关键字，但是没有参与编译，不起作用。\n要想用户信息不参与sQ语句的编译，那么必须使用java.sgl.Preparedstatement\nPreparedstatement是属于预编译的数据库操作对象，原理是：预先对SQL语句的框架进行编译，然后再给SQL语句传”值”。用户输入的值即使有SQL语句的关键字，也没有和SQL语句一起编译\n\n\n两者区别\n\nStatement存在sgl注八问题，Preparedstatement解决了sQr注入问题。\nStatement,是编译一次执行一次。Preparedstatement是编译一次，可执行次。Preparedstatement效率较高一些。\nPreparedstatement会在编译阶段做类型的安全检查。\n\n  所有以后会常用Preparedstatement\n解决上方sql注入问题\npublic class UserLogin &#123;    public static void main(String[] args) throws Exception &#123;        //数据表已经准备好了 db03--&gt;user-login        //初始化界面        //要返回用户输入的账号和密码        Map&lt;String, String&gt; userLoginInfo = initUI();        //验证用户名和密码        boolean loginSuccess = login(userLoginInfo);        /**         * 请输入账号: sdsa         * 请输入密码：sdsa &#x27; or &#x27;1&#x27; = &#x27;1         * 登录成功         *         * sql注入。。。。。         * 用户输入的语句中含有sql关键字，并且这些关键字参与了sql语句的编译过程         * 导致达到sql注入         */        //返回结果        System.out.println(loginSuccess ? &quot;登录成功&quot; : &quot;登录失败&quot;);    &#125;    /**     * @param userLoginInfo     * @return 判断的结果     * @Description 判断账号密码是否正确     */    private static boolean login(Map&lt;String, String&gt; userLoginInfo) throws Exception &#123;        boolean loginSuccess = false;        //用户信息        String userName = userLoginInfo.get(&quot;loginName&quot;);        String userPwd = userLoginInfo.get(&quot;loginPwd&quot;);        //jdbc                //获取连接        Connection connection = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/db03&quot;, &quot;root&quot;, &quot;abcd1234&quot;);        //创建PreparedStatement对象        String sql = &quot;select * from `user-login` where loginName = ? and loginPwd = ?&quot;;        PreparedStatement ps = connection.prepareStatement(sql);        //给?符号复赋值        ps.setString(1, userName);        ps.setString(2, userPwd);        // 执行sql语句        ResultSet resultSet = ps.executeQuery();        //返回结果        if(resultSet.next())&#123;            loginSuccess = true;        &#125;        //释放资源        if (statement != null) &#123;            statement.close();        &#125;        if (connection != null) &#123;            connection.close();        &#125;        return loginSuccess;    &#125;    /**     * @return 返回用户登录的账号密码     * @Description 初始化登录界面     */    private static Map&lt;String, String&gt; initUI() &#123;        Scanner sc = new Scanner(System.in);        System.out.println(&quot;请输入账号：&quot;);        String loginName = sc.nextLine();        System.out.println(&quot;请输入密码：&quot;);        String loginPwd = sc.nextLine();        HashMap&lt;String, String&gt; userLoginInfo = new HashMap&lt;&gt;();        userLoginInfo.put(&quot;loginName&quot;, loginName);        userLoginInfo.put(&quot;loginPwd&quot;, loginPwd);        return userLoginInfo;    &#125;&#125;\n\n6.jdbc相关api\n\n7.封装JDBCUtils在jdbc操作中，获取连接和释放资源是经常使用到可以将其封装DBC连接的工具类JDBCUtils\npublic class DBUtils &#123;    private static String url;    private static String user;    private static String password;    static &#123;        try &#123;            //提前在src目录下新建jdbc.propreties存放配置信息            //读取配置文件信息            Properties properties = new Properties();            properties.load(new FileInputStream(&quot;src\\\\jdbc.properties&quot;));            url = properties.getProperty(&quot;url&quot;);            user = properties.getProperty(&quot;user&quot;);            password = properties.getProperty(&quot;password&quot;);        &#125; catch (IOException e) &#123;            //转换为运行异常            new RuntimeException(e);        &#125;    &#125;    //连接数据库，返回Connection    public static Connection getConnection() &#123;        try &#123;            return DriverManager.getConnection(url, user, password);        &#125; catch (SQLException e) &#123;            //转换为运行异常            throw new RuntimeException(e);        &#125;    &#125;    //关闭相关资源    public static void close(ResultSet resultSet, Statement statement, Connection connection) &#123;        try &#123;            if (resultSet != null) &#123;                resultSet.close();            &#125;            if (statement != null) &#123;                statement.close();            &#125;            if (connection != null) &#123;                connection.close();            &#125;        &#125; catch (SQLException e) &#123;            //转换为运行异常            throw new RuntimeException(e);        &#125;    &#125;\n\nJDBCUtils的使用\npublic class DBUtils_Use &#123;    @Test    public void testDML() &#123;        //获取连接        Connection connection = null;        //准备sql语句        String sql = &quot;update actor set name = ? where id = ?&quot;;        //生产Statement对象        PreparedStatement ps = null;        try &#123;            connection = DBUtils.getConnection();            ps = connection.prepareStatement(sql);            //给占位符赋值            ps.setString(1, &quot;张三丰&quot;);            ps.setInt(2, 4);            int count = ps.executeUpdate();            System.out.println(count == 1 ? &quot;成功&quot; : &quot;失败&quot;);        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125; finally &#123;            DBUtils.close(null, ps, connection);        &#125;    &#125;&#125;\n\n8. 事务\n基本介绍\n\nJDBC程序中当一个Connection对象创建时，默认情况下是自动提交事务：每次执行一SQL语句时，如果执行成功，就会向数据库自动提交，而不能回滚。\nJDBC程序中为了让多个SQL语句作为一个整体执行，需要使用事务\n调用Connection的setAutoCommit(false)可以取消自动提交事务\n在所有的sQL语句都成功执行后，调用Connection的commit(0:方法提交事务在其中某个操作失败或出现异常时，调用Connection的rollback();方法回滚事务\n\n\n应用案例\n经典的模拟转账业务\npublic class Jdbc09 &#123;    public static void main(String[] args) throws SQLException &#123;        Connection connection = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/db03&quot;,                &quot;root&quot;, &quot;abcd1234&quot;);        //用户111余额改为1000        String sql = &quot;update t_acnt set balance = ? where actno = ?&quot;;        PreparedStatement ps = connection.prepareStatement(sql);        ps.setDouble(1, 1000);        ps.setInt(2, 111);        int count = ps.executeUpdate();        //这里会出现空指针异常        String s = null;        s.toString();        //222改为1000        ps.setDouble(1, 1000);        ps.setInt(2, 222);        count += ps.executeUpdate();        System.out.println(count == 2 ? &quot;成功&quot; : &quot;失败&quot;);        //关闭资源        ps.close();        connection.close();    &#125;&#125;\n\n上面代码执行后会发现用户111少了1000块钱，而在给用户二增加余额的时候出现了其他异常，导致用户二并没有收到用户111的1000块钱，解决方法：将自动提交事务关闭就好\npublic class Jdbc09 &#123;    public static void main(String[] args) throws SQLException &#123;        Connection connection = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/db03&quot;,                &quot;root&quot;, &quot;abcd1234&quot;);        //将自动提交改为手动提交,程序末尾需要手动提交        connection.setAutoCommit(false);        //111改为1000        String sql = &quot;update t_acnt set balance = ? where actno = ?&quot;;        PreparedStatement ps = connection.prepareStatement(sql);        ps.setDouble(1, 1000);        ps.setInt(2, 111);        int count = ps.executeUpdate();        //这里会出现异常        String s = null;        s.toString();        //即使出现异常，不会自动提交，并且回到转账之前的状态        //将自动提交机制改为手动提交即可        //222改为1000        ps.setDouble(1, 1000);        ps.setInt(2, 222);        count += ps.executeUpdate();        System.out.println(count == 2 ? &quot;成功&quot; : &quot;失败&quot;);        //手动提交        connection.commit();        //如果出现错误则需要回滚        if (connection != null) &#123;            connection.rollback();        &#125;        //关闭资源        ps.close();        connection.close();    &#125;&#125;\n\n9.批处理\n基本介绍\n\n当需要成批插入或者更新记录时。可以采用Java的批量更新机制，这一机制允许多条语句一次性提交给数据库批量处理。通常情况下比单独提交处理更有效率。\nJDBC的批量处理语句包括下面方法：\naddBatch():添加需要批量处理的SQL语句或参数\nexecuteBatch():执行批量处理语句；\nclearBatch():清空批处理包的语句\n\n\nJDBC连接MySQL时，如果要使用批处理功能，请再u中加参数：?rewriteBatchedStatements&#x3D;true \n批处理往往和PreparedStatement-一起搭配使用，可以既减少编译次数，又减少运行次数，效率大大提高\n\n\n应用实例\n演示向admin表中添加5000条数据，注意耗时时间\npublic class Batch &#123;    /**     * 将5000条数据加入到admin表中要多久     * 普通方法耗时：9788     */    @Test    public void noBatch() throws Exception &#123;        Connection connection = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/db01&quot;,                &quot;root&quot;, &quot;abcd1234&quot;);        String sql = &quot;insert into admin2 values(null,?, ?)&quot;;        PreparedStatement ps = connection.prepareStatement(sql);        System.out.println(&quot;开始执行&quot;);        long start = System.currentTimeMillis();        for (int i = 0; i &lt;5000 ; i++) &#123;            ps.setString(1,&quot;tom&quot; +i);            ps.setInt(2,666);            ps.executeUpdate();        &#125;        long end = System.currentTimeMillis();        System.out.println(&quot;耗时：&quot;+(end-start));        //关闭连接        ps.close();        connection.close();    &#125;\n\n使用批量处理\n/**     * 使用批量处理     * 耗时：898     * 要.setAutoCommit(false);     * jdbc8.0以上要把自动提交关掉才可以     */    @Test    public void noBatch2() throws Exception &#123;        //末尾要加上?rewriteBatchedStatements=true&quot;        Connection connection = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/db01?rewriteBatchedStatements=true&quot;,                &quot;root&quot;, &quot;abcd1234&quot;);        connection.setAutoCommit(false);        String sql = &quot;insert into admin2 values(null,?, ?)&quot;;        PreparedStatement ps = connection.prepareStatement(sql);        System.out.println(&quot;开始执行&quot;);        long start = System.currentTimeMillis();        for (int i = 0; i &lt;5000 ; i++) &#123;            ps.setString(1,&quot;tom&quot; +i);            ps.setInt(2,666);            //将数据添加到待处理            ps.addBatch();            //当数据达到1000条的时候提交            if ((i+1) % 1000 == 0)&#123;                ps.executeBatch();                //提交后清理待处理                ps.clearBatch();            &#125;        &#125;        long end = System.currentTimeMillis();        System.out.println(&quot;耗时：&quot;+(end-start));        //关闭连接        ps.close();        connection.close();    &#125;&#125;\n\n10.数据库连接池\n5000次连接数据库问题\n传统方式 5000 次 耗时&#x3D;7099\npublic void testCon() &#123;//看看连接-关闭 connection 会耗用多久\tlong start = System.currentTimeMillis();\tSystem.out.println(&quot;开始连接.....&quot;);\tfor (int i = 0; i &lt; 5000; i++) &#123;//使用传统的 jdbc 方式，得到连接\t\tConnection connection = JDBCUtils.getConnection();//做一些工作，比如得到 PreparedStatement ，发送 sql//.......... //关闭\t\tJDBCUtils.close(null, null, connection);\t&#125;\tlong end = System.currentTimeMillis();\tSystem.out.println(&quot;传统方式 5000 次 耗时=&quot; + (end - start));    //传统方式 5000 次 耗时=7099\t&#125;&#125;\n\n传统解决方法分析\n\n传统的DBC数据库连接使用DriverManager来获取，.每次向数据库建立连接的时候都要将Connection加载到内存中，再验证lP地址，用户名和密码(0.05s~1s时间)。需要数据库连接的时候，就向数据库要求个频繁的进行数据库连接操作将占用很多的系统资源，容易造成服务器崩溃。\n每一次数据库连接，使用完后都得断开，如果程序出现异常而未能关闭，将导致数据库内存泄漏，最终将导致重启数据库。\n传统获取连接的方式，不能控制创建的连接数量，如连接过多，也可能导致内存泄漏，MySQL崩溃。\n解决传统开发中的数据库连接问题，可以采用数据库连接池技术\n\n\n数据库连接池\n\nJDBC的数据库连接池使用javax.sgl.DataSource来表示，DataSource只是一个接口，该接口通常由第三方提供实现[提供jar]\nC3P0数据库连接池，速度相对较慢，稳定性不错(hibernate,spring)(常用的)\nDBCP数据库连接池，速度相对c3pO较快，但不稳定\nProxool数据库连接池，有监控连接池状态的功能，稳定性较c3pO差一点\nBoneCP数据库连接池，速度快\nDruid(德鲁伊)是阿里提供的数据库连接池，集DBCP、c3PO、Proxool优点于一身的数据库连接池(常用的)\n\n\nDruid(德鲁伊应用实例)\n用德鲁伊连接500000此数据库,耗时：1183ms\npublic class Druid &#123;    public static void main(String[] args) throws Exception &#123;        //导入jar包        //加入配置文件到src目录        //创建Properties对象读取配置文件        Properties properties = new Properties();        properties.load(new FileInputStream(&quot;src\\\\druid.properties&quot;));        //创建一个指定参数的数据库连接池 德鲁伊的连接池        DataSource dataSource = DruidDataSourceFactory.createDataSource(properties);        long start = System.currentTimeMillis();        for (int i = 0; i &lt; 550000; i++) &#123;            Connection connection = dataSource.getConnection();            connection.close();        &#125;        long end = System.currentTimeMillis();        System.out.println(&quot;耗时：&quot; + (end - start));    &#125;&#125;\n\n\n德鲁伊的工具类 JdbcUtilsByDruid\npublic class JdbcUtilsByDruid &#123;    private static DataSource ds;    //静态代码块完成初始化    static &#123;        try &#123;            Properties properties = new Properties();            properties.load(new FileInputStream(&quot;src\\\\druid.properties&quot;));            ds = DruidDataSourceFactory.createDataSource(properties);        &#125; catch (Exception e) &#123;            throw new RuntimeException(e);        &#125;    &#125;    /**     * @Description 得到连接     * @return     * @throws SQLException     */    public static Connection getConnection() throws SQLException &#123;        return ds.getConnection();    &#125;    /**     * 关闭连接池，只是将连接放回连接池而已     */        public static void close(ResultSet resultSet, Statement statement, Connection connection) &#123;        try &#123;            if (resultSet != null) &#123;                resultSet.close();            &#125;            if (statement != null) &#123;                statement.close();            &#125;            if (connection != null) &#123;                connection.close();            &#125;        &#125; catch (SQLException e) &#123;            throw new RuntimeException(e);        &#125;    &#125;&#125;\n\n\n德鲁伊工具类的使用\npublic class JdbcUtilsByDruid_Uses &#123;    public static void main(String[] args) &#123;        try &#123;            Connection connection = JdbcUtilsByDruid.getConnection();            String sql = &quot;select * from actor&quot;;            PreparedStatement ps = connection.prepareStatement(sql);            ResultSet resultSet = ps.executeQuery();            while (resultSet.next()) &#123;                System.out.println(resultSet.getString(&quot;name&quot;));            &#125;            JdbcUtilsByDruid.close(resultSet,ps,connection);        &#125; catch (SQLException e) &#123;            throw new RuntimeException(e);        &#125;    &#125;&#125;\n\n\nApache—DBUtils\n\n分析问题\n\n关闭connection后，resultSet结果集无法使用\nresultSet不利于数据的管理\n\n示意图\n\n\n基本介绍\n\ncommons-dbutils是Apache组织提供的一个开源JDBC工具类库，它是对JDBC的封装使用dbutils能极大简化jdbc编码的工作量[真的]。\n\nDbUtils类\n\nQueryRunner类：该类封装了SQL的执行，是线程安全的。可以实现增、删、改、查、批处理\n使用QueryRunner类实现查询\nsultSetHandler接口：该接口用于处理java.sql.ResultSet,将数据按要求转换为另一种形式\n\n\n\n\n\n应用实例\npublic class JDUtilsByDruid_Use &#123;    /**     * 测试查找语句     */    @Test    public void testQuery() throws SQLException &#123;        //1.得到连接        Connection connection = JdbcUtilsByDruid.getConnection();        //2。使用DBUtils类和接口，先引入DBUtils相关的jar,加入到本Project        //3.创建QueryRunner        QueryRunner queryRunner = new QueryRunner();        //4.就可以执行相关的方法，返回ArrayList结果集        String sql = &quot;select * from actor&quot;;        List&lt;Actor&gt; list = queryRunner.query(connection, sql, new BeanListHandler&lt;&gt;(Actor.class));        System.out.println(&quot;输出集合里的信息&quot;);        for (Actor actor : list) &#123;            System.out.println(actor);        &#125;        //关闭连接 resultSet 和 Statement 会被query自动关闭        JdbcUtilsByDruid.close(null, null, connection);    &#125;    /**     * 测试单行查询     */    @Test    public void testQuery2() throws SQLException &#123;        //获取连接        Connection connection = JdbcUtilsByDruid.getConnection();        //创建QueryRunner        QueryRunner queryRunner = new QueryRunner();        //执行查询语句        String sql = &quot;select * from actor where id = ?&quot;;        Actor actor = queryRunner.query(connection, sql, new BeanHandler&lt;&gt;(Actor.class), 3);        //返回结果        System.out.println(actor);        //释放资源        JdbcUtilsByDruid.close(null, null, connection);    &#125;    /**     * 完成返回结果是单行单列     */    @Test    public void testQueryScalarHandler() throws SQLException &#123;        //获取连接        Connection connection = JdbcUtilsByDruid.getConnection();        //创建QueryRunner        QueryRunner queryRunner = new QueryRunner();        //查询        String sql = &quot;select name from actor where id = ?&quot;;        Object query = queryRunner.query(connection, sql, new ScalarHandler&lt;&gt;(), 3);        System.out.println(query);        //释放资源        JdbcUtilsByDruid.close(null, null, connection);    &#125;    /**     * 演示DML语句(delete insert update)     */    @Test    public void testDML() throws SQLException &#123;        //获取连接        Connection connection = JdbcUtilsByDruid.getConnection();        //创建QueryRunner        QueryRunner queryRunner = new QueryRunner();        //执行DML语句        //String sql = &quot;update actor set name = ? where id = ?&quot;;        //String sql = &quot;insert into actor values(null,?,?,?,?)&quot;;        String sql = &quot;delete from actor where id = ?&quot;;        //返回的是受影响的行数        int affectedRow = queryRunner.update(connection, sql,3);        System.out.println(&quot;修改了&quot; + affectedRow + &quot;条语句&quot;);        //释放资源        JdbcUtilsByDruid.close(null, null, connection);    &#125;&#125;\n\n\n\n\nDAO 和增删改查通用方法-BasicDao\n\n先分析一个问题\napache-dbutils+Druid简化灯了JDBC开发，但还有不足：\n\nSQL语句是固定，不能通过参数传入，通用性不好，需要进行改进，更方便执行增删改查\n对于select操作，如果有返回值，返回类型不能固定，需要使用泛型\n将来的表很多，业务需求复杂，不可能只靠一个Java类完成引出&#x3D;&#x3D;&gt;BasicDAO画出示意图，看看在实际开发中，应该如何处理\n\n\n\n基本介绍\n\nDAO:data access object数据访问对象\n这样的通用类，称为BasicDao,是专门和数据库交互的，即完成对数据库（表）的crud操作。\n在BaiscDao的基础上，实现一张表对应一个Dao,更好的完成功能，比如Customer表Customer.java(javabean)-CustomerDao.java\n\n\n应用实例\njavaBean\n//javabean类public class Actor &#123;    private int id;    private String name;    private String sex;    private Date bornDate;    private String phone;    public Actor() &#123;    &#125;    public Actor(int id, String name, String sex, Date bornDate, String phone) &#123;        this.id = id;        this.name = name;        this.sex = sex;        this.bornDate = bornDate;        this.phone = phone;    &#125;    public int getId() &#123;        return id;    &#125;    public void setId(int id) &#123;        this.id = id;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public String getSex() &#123;        return sex;    &#125;    public void setSex(String sex) &#123;        this.sex = sex;    &#125;    public Date getBornDate() &#123;        return bornDate;    &#125;    public void setBornDate(Date bornDate) &#123;        this.bornDate = bornDate;    &#125;    public String getPhone() &#123;        return phone;    &#125;    public void setPhone(String phone) &#123;        this.phone = phone;    &#125;    @Override    public String toString() &#123;        return &quot;Actor&#123;\\n&quot; +                &quot;id=&quot; + id +                &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &quot;, sex=&quot; + sex +                &quot;, bornDate=&quot; + bornDate +                &quot;, phone=&#x27;&quot; + phone + &#x27;\\&#x27;&#x27; +                &#x27;&#125;&#x27;;    &#125;&#125;\n\n德鲁伊工具类\n//德鲁伊工具类public class JdbcUtilsByDruid &#123;    private static DataSource ds;    //静态代码块完成初始化    static &#123;        try &#123;            Properties properties = new Properties();            properties.load(new FileInputStream(&quot;src\\\\druid.properties&quot;));            ds = DruidDataSourceFactory.createDataSource(properties);        &#125; catch (Exception e) &#123;            throw new RuntimeException(e);        &#125;    &#125;    /**     * @Description 得到连接     * @return     * @throws SQLException     */    public static Connection getConnection() throws SQLException &#123;        return ds.getConnection();    &#125;    /**     * 关闭连接池，只是将连接放回连接池而已     */    public static void close(ResultSet resultSet, Statement statement, Connection connection) &#123;        try &#123;            if (resultSet != null) &#123;                resultSet.close();            &#125;            if (statement != null) &#123;                statement.close();            &#125;            if (connection != null) &#123;                connection.close();            &#125;        &#125; catch (SQLException e) &#123;            throw new RuntimeException(e);        &#125;    &#125;&#125;\n\nBasicDAO其他 DAO 的父类, 使用到 apache-dbutils\npublic class BasicDAO&lt;T&gt; &#123;    private QueryRunner qr = new QueryRunner();    /**     * @param sql        要执行的sql语句 可以有?符号     * @param parameters 可变形参     * @return 受影响的行数     * @Description 基本的DML方法     */    public int update(String sql, Object... parameters) &#123;        Connection connection = null;        try &#123;            //获取链接            connection = JdbcUtilsByDruid.getConnection();            //执行sql语句            int update = qr.update(connection, sql, parameters);            return update;        &#125; catch (SQLException e) &#123;            throw new RuntimeException(e);        &#125; finally &#123;            JdbcUtilsByDruid.close(null, null, connection);        &#125;    &#125;    /**     * @param sql        要执行的sql语句 可以有?符号     * @param clazz      传入一个类的class     * @param parameters 对象     * @return 传入？的具体的值 可以说多个     * @Description 根据传入的class返回对应的ArrayList集合     */    public List&lt;T&gt; queryMulti(String sql, Class&lt;T&gt; clazz, Object... parameters) &#123;        Connection connection = null;        try &#123;            //获取链接            connection = JdbcUtilsByDruid.getConnection();            //执行sql语句            return qr.query(connection, sql, new BeanListHandler&lt;T&gt;(clazz), parameters);        &#125; catch (SQLException e) &#123;            throw new RuntimeException(e);        &#125; finally &#123;            JdbcUtilsByDruid.close(null, null, connection);        &#125;    &#125;    /**     * @param sql        要执行的sql语句 可以有?符号     * @param clazz      传入一个类的class     * @param parameters 传入？的具体的值 可以多个     * @return 根据传入的class返回对应的对象     * @Description 查询单行结果通用的方法     */    public T querySingle(String sql, Class&lt;T&gt; clazz, Object... parameters) &#123;        Connection connection = null;        try &#123;            //获取链接            connection = JdbcUtilsByDruid.getConnection();            //执行sql语句            return qr.query(connection, sql, new BeanHandler&lt;T&gt;(clazz), parameters);        &#125; catch (SQLException e) &#123;            throw new RuntimeException(e);        &#125; finally &#123;            JdbcUtilsByDruid.close(null, null, connection);        &#125;    &#125;    /**     * @param sql        要执行的sql语句 可以有?符号     * @param parameters 传入？的具体的值 可以多个     * @return 查询到的对象     * @Description 查询单行结果的通用方法     */    public Object queryScalar(String sql, Object... parameters) &#123;        Connection connection = null;        try &#123;            //获取链接            connection = JdbcUtilsByDruid.getConnection();            //执行sql语句            return qr.query(connection, sql, new ScalarHandler&lt;&gt;(), parameters);        &#125; catch (SQLException e) &#123;            throw new RuntimeException(e);        &#125; finally &#123;            JdbcUtilsByDruid.close(null, null, connection);        &#125;    &#125;&#125;\n\njavabean的DAO类\npublic class ActorDAO extends BasicDAO&lt;Actor&gt; &#123;    //继承了BasicDAO所有BasicDAO的所有方法    //根据业务需求，可以编写特有的方法&#125;\n\n测试类\npublic class TestDAO &#123;    public static void main(String[] args) &#123;        System.out.println(new TestDAO().testDAO4());    &#125;    /**     * @Description 对ActorDAO对Actor表的增删改查     */    @Test    public void testDAO() &#123;        ActorDAO actorDAO = new ActorDAO();        //查询        List&lt;Actor&gt; actors = actorDAO.queryMulti(&quot;select * from actor where id &gt; ?&quot;, Actor.class, 1);        for (Actor actor : actors) &#123;            System.out.println(actor);        &#125;    &#125;    /**     * @Description 测试返回单行的数据     */    @Test    public void testDAO2() &#123;        ActorDAO actorDAO = new ActorDAO();        Object o = actorDAO.queryScalar(&quot;select name from actor where id = ?&quot;, 5);        System.out.println(o);    &#125;    /**     * @Description 查询单行单列     */    @Test    public void testDAO3() &#123;        ActorDAO actorDAO = new ActorDAO();        Actor actor = actorDAO.querySingle(&quot;select name from actor where id = ?&quot;, Actor.class, 5);        System.out.println(actor);    &#125;    /**     * @Description dml操作     */    @Test    public int testDAO4() &#123;        ActorDAO actorDAO = new ActorDAO();        int count = actorDAO.update(&quot;insert into actor values(null,?,?,?,?)&quot;, &quot;王多鱼&quot;, &quot;男&quot;, &quot;2022-06-19&quot;, &quot;1102&quot;);        System.out.println(count &gt; 0 ? &quot;执行成功&quot; : &quot;失败&quot;);        return count;    &#125;&#125;\n\n\n\n","tags":["学习笔记"]},{"title":"Javaweb笔记","url":"/2022/07/02/Javaweb%E7%AC%94%E8%AE%B0/","content":"JavaWeb笔记1. Web概述1.1 B&#x2F;S架构B&#x2F;S 架构：Browser&#x2F;Server,浏览器&#x2F;服务器 架构模式\n用户通过浏览器就能访问到服务器的资源，好处是易维护\n\n1.2 HTTP协议\nHTTP协议:主要定义通信规则\n浏览器发送请求给服务器，服务器响应数据给浏览器，这整个过程都需要遵守一定的规则，之前大家学习过TCP、UDP，这些都属于规则，这里我们需要使用的是HTTP协议，这也是一种规则。\n\n1.3 Web服务器\nWeb服务器:负责解析 HTTP 协议，解析请求数据，并发送响应数据\n浏览器按照HTTP协议发送请求和数据，后台就需要一个Web服务器软件来根据HTTP协议解析请求和数据，然后把处理结果再按照HTTP协议发送给浏览器\nWeb服务器软件有很多，我们课程中将学习的是目前最为常用的Tomcat服务器\n\n2. HTTP2.1 HTTP概念HyperText Transfer Protocol，超文本传输协议，规定了浏览器和服务器之间数据传输的规则。\n\n数据传输的规则指的是请求数据和响应数据需要按照指定的格式进行传输。\n\n可以打开浏览器，点击F12打开开发者工具，点击Network来查看某一次请求的请求数据和响应数据具体的格式内容，如下图所示:\n\n\n\n2.2 HTTP特点HTTP协议有它自己的一些特点，分别是:\n\n基于TCP协议: 面向连接，安全\n\n基于请求-响应模型的:一次请求对应一次响应\n\nHTTP协议是无状态协议:对于事物处理没有记忆能力。每次请求-响应都是独立的\n\n缺点:多次请求间不能共享数据\n优点:速度快\n\n请求之间无法共享数据会引发的问题，如京东购物，加入购物车和去购物车结算是两次请求\n\n\n2.3 请求数据格式请求数据总共分为三部分内容，分别是 请求行、请求头、请求体\n\n\n请求行: HTTP请求中的第一行数据，请求行包含三块内容，分别是 GET[请求方式] &#x2F;[请求URL路径] HTTP&#x2F;1.1[HTTP协议及版本]\n\n请求头: 第二行开始，格式为key: value形式\n请求头中会包含若干个属性，常见的HTTP请求头有:\n\nHost: 表示请求的主机名\nUser-Agent: 浏览器版本,例如Chrome浏览器的标识\nAccept：表示浏览器能接收的资源类型，如text&#x2F;*，image&#x2F;或者&#x2F;*表示所有；\nAccept-Language：表示浏览器偏好的语言，服务器可以据此返回不同语言的网页；\nAccept-Encoding：表示浏览器可以支持的压缩类型，例如gzip, deflate等。\n\n\n请求体: POST请求的最后一部分，存储请求参数\n\n如上图红线框的内容就是请求体的内容\nGET和POST两个请求之间的区别：\n\nGET请求请求参数在请求行中，没有请求体，POST请求请求参数在请求体中\nGET请求请求参数大小有限制，POST没有\n\n\n\n2.4 响应数据格式响应数据总共分为三部分内容，分别是 响应行、响应头、响应体\n\n\n响应行：响应数据的第一行,响应行包含三块内容，分别是 HTTP&#x2F;1.1[HTTP协议及版本] 200[响应状态码] ok[状态码的描述]\n\n响应头：第二行开始，格式为key：value形式\n响应头中会包含若干个属性，常见的HTTP响应头有:\n\nContent-Type：表示该响应内容的类型，例如text&#x2F;html，image&#x2F;jpeg；\nContent-Length：表示该响应内容的长度（字节数）；\nContent-Encoding：表示该响应压缩算法，例如gzip；\nCache-Control：指示客户端应如何缓存，例如max-age&#x3D;300表示可以最多缓存300秒\n\n\n响应体： 最后一部分。存放响应数据\n上图中…这部分内容就是响应体，它和响应头之间有一个空行隔开。\n\n\n2.4.2 响应状态码关于响应状态码，我们先主要认识三个状态码，其余的等后期用到了再去掌握:\n\n200  ok 客户端请求成功\n404  Not Found 请求资源不存在\n500 Internal Server Error 服务端发生不可预期的错误\n\n状态码大全：https://cloud.tencent.com/developer/chapter/13553 \n3. Tomcat3.1 什么是Web服务器Web服务器是一个应该程序 软件，对HTTP协议的操作进行封装，使得程序员不必直接对协议进行操作，让Web开发更加便捷。主要功能是”提供网上信息浏览服务”。\n\n Web服务器是安装在服务器端的一款软件，将来我们把自己写的Web项目部署到Web Tomcat服务器软件中，当Web服务器软件启动后，部署在Web服务器软件中的页面就可以直接通过浏览器来访问了。\n3.2 Tomcat的相关概念:\nTomcat是Apache软件基金会一个核心项目，是一个开源免费的轻量级Web服务器，支持Servlet&#x2F;JSP少量JavaEE规范。\n\navaEE规范呢：\nJavaEE: Java Enterprise Edition,Java企业版。指Java企业级开发的技术规范总和。包含13项技术规范:JDBC、JNDI、EJB、RMI、JSP、Servlet、XML、JMS、Java IDL、JTS、JTA、JavaMail、JAF。\n\n因为Tomcat支持Servlet&#x2F;JSP规范，所以Tomcat也被称为Web容器、Servlet容器。Servlet需要依赖Tomcat才能运行。\n\nTomcat的官网: https://tomcat.apache.org/ 从官网上可以下载对应的版本进行使用。\n\n\n3.3 基本使用3.3.1 下载直接从官网下载\n\n3.3.2 安装\nTomcat是绿色版,直接解压即可,解压目录最号不包含中文\n\n解压后会得到一个目录：apache-tomcat-9.0.xx,Tomcat就已经安装成功。\n\n目录结构，每个目录中包含的内容需要认识下：\n\nbin:目录下有两类文件，一种是以.bat结尾的，是Windows系统的可执行文件，一种是以.sh结尾的，是Linux系统的可执行文件。\nwebapps:就是以后项目部署的目录\n到此，Tomcat的安装就已经完成。\n\n\n3.3.3 配置环境变量因为Tomcat是java写的，所有运行时必须要有JRE运行环境\n\nJava环境变量：\n系统变量 –&gt; 新建：JAVA_HOME后面跟着的是JAVA的根目录\n\n找到系统变量 –&gt; Path 点击编辑 新建 输入 %JAVA_HOME%\\bin 和 %JAVA_HOME%\\jre\\bin\n\n\nTomcat环境变量\n系统变量 –&gt; 新建：CATALINA_HOME后面跟着的是Tomcat的根目录\n\n找到系统变量 –&gt; Path 点击编辑 新建 输入 %CATALINA_HOME%\\bin 和 %CATALINA_HOME%\\lib\n\n\n\n打开CMD,输入catalina -version，会显示以下信息\n\n接着输入startup.bat将会启动Tomcat,浏览器输入http://localhost:8080就能访问到Tomcat\n\n\n3.3.4 解决tomcat在CMD乱码问题CMD乱码在CMD目录下按下ctrl+c 关闭Tomcat,找到 Tomcat安装目录下的 conf –&gt;logging.properties编辑文件，找到 java.util.logging.ConsoleHandler.encoding &#x3D; UTF-8，改为java.util.logging.ConsoleHandler.encoding &#x3D; GBK,保存退出重新启动一下Tomcat，检查一下。\n\n修复在idea控制台下乱码的问题找到 Tomcat安装目录下的 conf –&gt;logging.properties编辑文件，找到 \n\n将UTF-8改为GBK，重启Tomcat服务器就好\n3.3.5配置修改端口\n\nTomcat默认的端口是8080，要想修改Tomcat启动的端口号，需要修改 conf&#x2F;server.xml\n\n3.3.6部署Tomcat部署项目： 将项目放置到webapps目录下，即部署完成。\n\n可以将之前的html页面目录目录拷贝到Tomcat的webapps目录下\n\n通过浏览器访问http://localhost/目录/html文件，能看到下面的内容就说明项目已经部署成功。\n\n\n一般JavaWeb项目会被打包称 war 包，然后将war包放到Webapps目录下，Tomcat会自动解压缩war文件\n\n\n至此，Tomcat的部署就已经完成了，至于如何获得项目对应的war包，后期我们会借助于IDEA工具来生成。\n3.4 Maven创建Web项目3.4.1 Web项目结构\nMaven Web项目结构: 开发中的项目\n\n\n开发完成部署的Web项目\n\n\n开发项目通过执行Maven打包命令 package,可以获取到部署的Web项目目录\n编译后的Java字节码文件和resources的资源文件，会被放到WEB-INF下的classes目录下\npom.xml中依赖坐标对应的jar包，会被放入WEB-INF下的lib目录下\n\n\n\n3.4.2 创建Maven Web项目创建方式有两种:使用骨架和不使用骨架\n使用骨架\n\n不使用骨架\n\n\n\n3.5 IDEA使用Tomcat 将刚才本地安装好的Tomcat9集成到IDEA中，完成项目部署，具体的实现步骤\n\n\n\n\n\n4. Servlet4.1 简介\nServlet是JavaWeb最为核心的内容，它是Java提供的一门 动态web资源开发技术。\n\n使用Servlet就可以实现，根据不同的登录用户在页面上动态显示不同内容。\n\nServlet是JavaEE规范之一，其实就是一个接口，将来我们需要定义Servlet类实现Servlet接口，并由web服务器运行Servlet\n\n\n4.2  快速入门编写一个Servlet类，并使用IDEA中Tomcat插件进行部署，最终通过浏览器访问所编写的Servlet程序\n1.创建Web项目web-demo，导入Servlet依赖坐标\n&lt;dependencies&gt;  &lt;dependency&gt;    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;    &lt;version&gt;4.0.1&lt;/version&gt;    &lt;!-- 加入provided只在编译和运行环境有效， 防止和tomcat自带的servlet-api发生冲突--&gt;    &lt;scope&gt;provided&lt;/scope&gt;  &lt;/dependency&gt;&lt;/dependencies&gt;\n\n2.创建:定义一个类，实现Servlet接口，并重写接口中所有方法，并在service方法中输入一句话\n//在类上使用@WebServlet注解，配置该Servlet的访问路径@WebServlet(&quot;/demo01&quot;)public class ServletDemo01 implements Servlet &#123;    @Override    public void init(ServletConfig servletConfig) throws ServletException &#123;    &#125;    @Override    public ServletConfig getServletConfig() &#123;        return null;    &#125;    @Override    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123;        System.out.println(&quot;hello Servlet &quot;);    &#125;    @Override    public String getServletInfo() &#123;        return null;    &#125;    @Override    public void destroy() &#123;    &#125;&#125;\n\n3.访问:启动Tomcat,浏览器中输入localhost:8080访问该Servlet\n4.浏览器访问后，在控制台会打印hello Servlet 说明servlet程序已经成功运行。\n4.3 执行流程\n浏览器发出http://localhost:8080/web-demo/demo1请求，从请求中可以解析出三部分内容，分别是localhost:8080、web-demo、demo1\n\n根据localhost:8080可以找到要访问的Tomcat Web服务器\n根据web-demo可以找到部署在Tomcat服务器上的web-demo项目\n根据demo1可以找到要访问的是项目中的哪个Servlet类，根据@WebServlet后面的值进行匹配\n\n找到ServletDemo1这个类后，Tomcat Web服务器就会为ServletDemo1这个类创建一个对象，然后调用对象中的service方法\n\nServletDemo1实现了Servlet接口，所以类中必然会重写service方法供Tomcat Web服务器进行调用\nservice方法中有ServletRequest和ServletResponse两个参数，ServletRequest封装的是请求数据，ServletResponse封装的是响应数据，后期我们可以通过这两个参数实现前后端的数据交互\n\n两个问题：\n\nServlet由谁创建?Servlet方法由谁调用?\nServlet由web服务器创建，Servlet方法由web服务器调用\n\n服务器怎么知道Servlet中一定有service方法?\n因为我们自定义的Servlet,必须实现Servlet接口并复写其方法，而Servlet接口中有service方法\n\n\n4.4 生命周期\n生命周期: 对象的生命周期指一个对象从被创建到被销毁的整个过程。\n\nServlet运行在Servlet容器(web服务器)中，其生命周期由容器来管理，分为4个阶段：\n\n加载和实例化：默认情况下，当Servlet第一次被访问时，由容器创建Servlet对象\n默认情况，Servlet会在第一次访问被容器创建，但是如果创建Servlet比较耗时的话，那么第一个访问的人等待的时间就比较长，用户的体验就比较差，这是可以让服务器启动时创建servlet@WebServlet(urlPatterns = &quot;/demo1&quot;,loadOnStartup = 1)loadOnstartup的取值有两类情况\t（1）负整数:第一次访问时创建Servlet对象\t（2）0或正整数:服务器启动时创建Servlet对象，数字越小优先级越高\n\n初始化：在Servlet实例化之后，容器将调用Servlet的 init() 方法初始化这个对象，完成一些如加载配置文件、创建连接等初始化的工作。该方法只 调用一次\n\n请求处理：每次请求Servlet时，Servlet容器都会调用Servlet的service() 方法对请求进行处理\n\n服务终止：当需要释放内存或者容器关闭时，容器就会调用Servlet实例的 destroy() 方法完成资源的释放。在destroy()方法调用之后，容器会释放这个Servlet实例，该实例随后会被Java的垃圾收集器所回收\n@WebServlet(urlPatterns = &quot;/demo02&quot;,loadOnStartup = 0)public class ServletDemo02 implements Servlet &#123;    /**     * 第一次访问Servlet的时候才会执行，只会执行1次     * loadOnStartup 更改启动时间，可以做到服务器启动时执行init方法     * @param servletConfig     * @throws ServletException     */    @Override    public void init(ServletConfig servletConfig) throws ServletException &#123;        System.out.println(&quot;正在初始化&quot;);    &#125;    /**     * 每次访问Servlet时会调用此方法     * @param servletRequest     * @param servletResponse     * @throws ServletException     * @throws IOException     */    @Override    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123;        System.out.println(&quot;hello Servlet &quot;);    &#125;    /**     * Servlet被销毁时会调用此方法     */    @Override    public void destroy() &#123;        System.out.println(&quot;正在销毁&quot;);    &#125;    @Override    public ServletConfig getServletConfig() &#123;        return null;    &#125;    @Override    public String getServletInfo() &#123;        return null;    &#125;&#125;\n\n\n\n4.5 方法介绍\n初始化方法，在Servlet被创建时执行，只执行一次\nvoid init(ServletConfig config) \n\n提供服务方法， 每次Servlet被访问，都会调用该方法\nvoid service(ServletRequest req, ServletResponse res)\n\n销毁方法，当Servlet被销毁时，调用该方法。在内存释放或服务器关闭时销毁Servlet\nvoid destroy() \n\n获取Servlet信息，返回Servlet的相关信息(用的不多)\npublic String getServletInfo() &#123;    return &quot;&quot;;&#125;\n\n获取ServletConfig对象\nServletConfig getServletConfig()\n\n4.6 体系结构编写一个Servlet就必须要实现Servlet接口，重写接口中的5个方法，太麻烦了，有更简单的方式，首先要了解Servlet的体系结构\n\n因为我们将来开发B&#x2F;S架构的web项目，都是针对HTTP协议，所以我们自定义Servlet,会通过继承HttpServlet\npublic class ServletDemo05 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        //TODO GET 请求方式处理逻辑        System.out.println(&quot;get...&quot;);    &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        //TODO Post 请求方式处理逻辑        System.out.println(&quot;post...&quot;);    &#125;&#125;\n\n\n要想发送一个GET请求，请求该Servlet，只需要通过浏览器发送http://localhost:8080/web-demo/demo5,就能看到doGet方法被执行了\n\n要想发送一个POST请求，请求该Servlet，单单通过浏览器是无法实现的，这个时候就需要编写一个form表单来发送请求，在webapp下创建一个table.html页面，内容如下:\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;/Web_Demo/demo04&quot; method=&quot;post&quot;&gt;    姓名：&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt; &lt;br&gt;    年龄：&lt;input type=&quot;number&quot; name=&quot;age&quot;&gt; &lt;br&gt;    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;\n\n启动测试，即可看到doPost方法被执行了。\n问题:\n\nHttpServlet中为什么要根据请求方式的不同，调用不同的方法?\n前端发送GET和POST请求的时候，参数的位置不一致,GET请求参数在请求行中，POST请求参数在请求体中,为了能处理不同的请求方式，我们得在service方法中进行判断，然后写不同的业务处理.\n\n\n\n\n4.7 urlPattern配置\nServlet类编写好后，要想被访问到，就需要配置其访问路径\nurlPattern: 一个Servlet可以配置多个访问路径\n@WebServlet(urlPatterns = &#123;&quot;/demo06&quot;,&quot;/demo07&quot;&#125;)public class ServletDemo05 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        System.out.println(&quot; demo05 get....&quot;);    &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        System.out.println(&quot; demo05 post....&quot;);    &#125;&#125;\n\n在浏览器上输入http://localhost:8080/web-demo/demo7,http://localhost:8080/web-demo/demo8这两个地址都能访问到ServletDemo5的doGet方法。\n\n精确匹配\n@WebServlet(urlPatterns = &quot;/user/servlet&quot;)public class ServletDemo05 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        System.out.println(&quot; demo05 get....&quot;);    &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        System.out.println(&quot; demo05 post....&quot;);    &#125;&#125;\n\n访问路径http://localhost:8080/web-demo/user/select\n\n目录匹配\n@WebServlet(urlPatterns = &quot;/user/*&quot;)public class ServletDemo05 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        System.out.println(&quot; demo05 get....&quot;);    &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        System.out.println(&quot; demo05 post....&quot;);    &#125;&#125;\n\n访问路径http://localhost:8080/web-demo/user/任意都能访问到\n/user/*中的/*代表的是零或多个层级访问目录同时精确匹配优先级要高于目录匹配。\n\n扩展名匹配\n@WebServlet(urlPatterns = &quot;*.do&quot;)public class ServletDemo05 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        System.out.println(&quot; demo05 get....&quot;);    &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        System.out.println(&quot; demo05 post....&quot;);    &#125;&#125;\n\n访问路径http://localhost:8080/web-demo/任意.do都能访问 \n\n任意匹配(不推荐使用)\n@WebServlet(urlPatterns = &quot;/&quot;)public class ServletDemo05 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        System.out.println(&quot; demo05 get....&quot;);    &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        System.out.println(&quot; demo05 post....&quot;);    &#125;&#125;\n\n@WebServlet(urlPatterns = &quot;/*&quot;)public class ServletDemo05 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        System.out.println(&quot; demo05 get....&quot;);    &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        System.out.println(&quot; demo05 post....&quot;);    &#125;&#125;\n\n访问路径http://localhost:8080/demo-web/任意都能访问\n\n\n总结：\n\nurlPattern总共有四种配置方式，分别是精确匹配、目录匹配、扩展名匹配、任意匹配\n\n五种配置的优先级为 精确匹配 &gt; 目录匹配&gt; 扩展名匹配 &gt; &#x2F;* &gt; &#x2F; ,无需记，以最终运行结果为准\n\n\n4.8 XML配置前面对应Servlet的配置，我们都使用的是@WebServlet,这个是Servlet从3.0版本后开始支持注解配置，3.0版本前只支持XML配置文件的配置方法。\n对于XML的配置步骤有两步:\n\n编写Servlet类\npublic class ServletDemo13 extends MyHttpServlet &#123;    @Override    protected void doGet(ServletRequest req, ServletResponse res) &#123;        System.out.println(&quot;demo13 get...&quot;);    &#125;    @Override    protected void doPost(ServletRequest req, ServletResponse res) &#123;    &#125;&#125;\n\n在web.xml中配置该Servlet\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;         version=&quot;4.0&quot;&gt;                &lt;!--         Servlet 全类名    --&gt;    &lt;servlet&gt;        &lt;!-- servlet的名称，名字任意--&gt;        &lt;servlet-name&gt;demo13&lt;/servlet-name&gt;        &lt;!--servlet的类全名--&gt;        &lt;servlet-class&gt;com.itheima.web.ServletDemo13&lt;/servlet-class&gt;    &lt;/servlet&gt;    &lt;!--         Servlet 访问路径    --&gt;    &lt;servlet-mapping&gt;        &lt;!-- servlet的名称，要和上面的名称一致--&gt;        &lt;servlet-name&gt;demo13&lt;/servlet-name&gt;        &lt;!-- servlet的访问路径--&gt;        &lt;url-pattern&gt;/demo13&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;&lt;/web-app&gt;\n\n这种配置方式和注解比起来，确认麻烦很多，所以建议大家使用注解来开发。但是大家要认识上面这种配置方式，因为并不是所有的项目都是基于注解开发的。\n\n\n5. Request&amp;&amp;Response5.1 Request和Response的概述Request是请求对象，Response是响应对象。这两个对象在我们使用Servlet的时候有看到：\n@WebServlet(&quot;/Servlet01&quot;)public class Servlet01 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;    &#125;    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        doGet(request, response);    &#125;&#125;\n\n\n\nrequest：请求数据\n浏览器会发送HTTP请求到后台服务器[Tomcat]\nHTTP的请求中会包含很多请求数据[请求行+请求头+请求体]\n后台服务器[Tomcat]会对HTTP请求中的数据进行解析并把解析结果存入到一个对象中\n所存入的对象即为request对象，所以我们可以从request对象中获取请求的相关参数\n获取到数据后就可以继续后续的业务，比如获取用户名和密码就可以实现登录操作的相关业务\n\n\nreponse：响应数据\n业务处理完后，后台就需要给前端返回业务处理的结果即响应数据\n把响应数据封装到response对象中\n后台服务器[Tomcat]会解析response对象,按照[响应行+响应头+响应体]格式拼接结果\n浏览器最终解析结果，把内容展示在浏览器给用户浏览\n\n\n\n体验一下\n@WebServlet(&quot;/test01&quot;)public class Servlet01 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        response.setContentType(&quot;text/html;charset=UTF-8&quot;);        String username = request.getParameter(&quot;username&quot;);        PrintWriter writer = response.getWriter();        writer.write(&quot;hello&quot; + username);    &#125;    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        doGet(request, response);    &#125;&#125;\n\n\n小结\nrequest对象是用来封装请求数据的对象\nresponse对象是用来封装响应数据的对象\n\n5.2 Request对象5.2.1 继承体系\n从上图中可以看出，ServletRequest和HttpServletRequest都是Java提供的，所以我们可以打开JavaEE提供的API文档\nServletRequest和HttpServletRequest是继承关系，并且两个都是接口，接口是无法创建对象的，这个时候，我们就需要用到Request继承体系中的RequestFacade:\n\n该类实现了HttpServletRequest接口，也间接实现了ServletRequest接口。\nServlet类中的service方法、doGet方法或者是doPost方法最终都是由Web服务器[Tomcat]来调用的，所以Tomcat提供了方法参数接口的具体实现类，并完成了对象的创建\n要想了解RequestFacade中都提供了哪些方法，我们可以直接查看JavaEE的API文档中关于ServletRequest和HttpServletRequest的接口文档，因为RequestFacade实现了其接口就需要重写接口中的方法\n\n小结\nRequest的继承体系为ServletRequest–&gt;HttpServletRequest–&gt;RequestFacade\nTomcat需要解析请求数据，封装为request对象,并且创建request对象传递到service方法\n使用request对象，可以查阅JavaEE API文档的HttpServletRequest接口中方法说明\n\n5.2.2 Request获取请求数据HTTP请求数据总共分为三部分内容，分别是请求行、请求头、请求体\n5.2.2.1获取请行求数据请求行包含三块内容，分别是请求方式、请求资源路径、HTTP协议及版本\n\n对于这三部分内容，request对象都提供了对应的API方法来获取，具体如下:\n获取请求方式: GET\nString getMethod()\n\n获取虚拟目录(项目访问路径): &#x2F;request-demo\nString getMethod()\n\n获取URL(统一资源定位符): http://localhost:8080/request-demo/req1\nStringBuffer getRequestURL()\n\n获取URI(统一资源标识符): &#x2F;request-demo&#x2F;req1&#96;\nString getRequestURI()\n\n获取请求参数(GET方式):\nString getQueryString()\n\n@WebServlet(&quot;/request01&quot;)public class RequestDemo01 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        //获取请求方式:        String method = req.getMethod();        System.out.println(&quot;Method: &quot; + method);        //获取虚拟目录(项目访问路径):        String contextPath = req.getContextPath();        System.out.println(&quot;contextPath: &quot; + contextPath);        //获取URL(统一资源定位符):        StringBuffer requestURL = req.getRequestURL();        System.out.println(&quot;requestURL: &quot; + requestURL.toString());        //获取URI(统一资源标识符):        String requestURI = req.getRequestURI();        System.out.println(&quot;requestURI: &quot; + requestURI);        //获取请求参数(GET方式):        String queryString = req.getQueryString();        System.out.println(&quot;queryString: &quot; + queryString);        //请求头名称 user-agent        String header = req.getHeader(&quot;user-agent&quot;);        System.out.println(&quot;header: &quot; + header);\n\n5.2.2.2 获取请求头数据对于请求头的数据，格式为key: value如下:\n\n所以根据请求头名称获取对应值的方法为:\nString getHeader(String name)\n\n获取浏览器的版本信息\n//请求头名称 user-agent        String header = req.getHeader(&quot;user-agent&quot;);        System.out.println(&quot;header: &quot; + header);\n\n5.2.2.3获取请求数据浏览器在发送GET请求的时候是没有请求体的，所以需要把请求方式变更为POST，请求体中的数据格式如下:\nusername=zs&amp;pwd=123456\n\n对于请求体中的数据，Request对象提供了如下两种方式来获取其中的数据，分别是:\n\n获取字节输入流，如果前端发送的是字节数据，比如传递的是文件数据，则使用该方法\nServletInputStream getInputStream()该方法可以获取字节\n\n\n\n获取字符输入流，如果前端发送的是纯文本数据，则使用该方法\nBufferedReader getReader()\n\n获取请求内容\n\n创建一个包含form表单的html文件，提交方式时post\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;/Web_Demo/req3&quot; method=&quot;get&quot;&gt;    username: &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt;    password: &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt;    hobby: &lt;input type=&quot;checkbox&quot; value=&quot;1&quot; name=&quot;hobby&quot;&gt;吃        &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;2&quot;&gt;睡    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n\n在Servlet的doPost方法中获取数据\n/** * request 获取请求数据 */@WebServlet(&quot;/req1&quot;)public class RequestDemo1 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;    &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        //在此处获取请求体中的数据    &#125;&#125;\n\n\n\n调用getReader()或者getInputStream()方法，因为目前前端传递的是纯文本数据，所以我们采用getReader()方法来获取\n/** * request 获取请求数据 */@WebServlet(&quot;/req1&quot;)public class RequestDemo1 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;    &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;         //获取post 请求体：请求参数        //1. 获取字符输入流        BufferedReader br = req.getReader();        //2. 读取数据        String line = br.readLine();        System.out.println(line);    &#125;&#125;\n\nBufferedReader流是通过request对象来获取的，当请求完成后request对象就会被销毁，request对象被销毁后，BufferedReader流就会自动关闭，所以此处就不需要手动关闭流了。\n\n\n小结\nHTTP请求数据中包含了请求行、请求头和请求体，针对这三部分内容，Request对象都提供了对应的API方法来获取对应的值:\n请求行：\n\ngetMethod()获取请求方式\ngetContextPath()获取项目访问路径\ngetRequestURL()获取请求URL\ngetRequestURI()获取请求URI\ngetQueryString()获取GET请求方式的请求参数\n\n请求头\n\ngetHeader(String name)根据请求头名称获取其对应的值\n\n请求体\n\n注意: &#x3D;&#x3D;浏览器发送的POST请求才有请求体&#x3D;&#x3D;\n如果是纯文本数据:getReader()\n如果是字节数据如文件数据:getInputStream()\n\n\n\n5.2.2.4 获取请求参数的通用方式\n什么是请求参数?\n在日常使用中用户名和密码其实就是我们所说的请求参数\n\n请求参数和请求数据的关系是什么?\n请求数据则是包含请求行、请求头和请求体的所有数据\n对于请求参数的获取,常用的有以下两种:\nGET方式：\n对于请求参数的获取,常用的有以下两种:\n\nPOST方式:\nBufferedReader getReader();\n\n有了上述的知识储备，我们来实现一个案例需求:\n（1）发送一个GET请求并携带用户名，后台接收后打印到控制台\n（2）发送一个POST请求并携带用户名，后台接收后打印到控制台\n@WebServlet(&quot;/req1&quot;)public class RequestDemo1 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        String result = req.getQueryString();        System.out.println(result);    &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        BufferedReader br = req.getReader();        String result = br.readLine();        System.out.println(result);    &#125;&#125;\n\nGET请求和POST请求获取请求参数的方式不一样，在获取请求参数这块该如何实现呢?\n\n方法一：\n@WebServlet(&quot;/req1&quot;)public class RequestDemo1 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        //获取请求方式        String method = req.getMethod();        //获取请求参数        String params = &quot;&quot;;        if(&quot;GET&quot;.equals(method))&#123;            params = req.getQueryString();        &#125;else if(&quot;POST&quot;.equals(method))&#123;            BufferedReader reader = req.getReader();            params = reader.readLine();        &#125;        //将请求参数进行打印控制台        System.out.println(params);          &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        this.doGet(req,resp);    &#125;&#125;\n\n使用request的getMethod()来获取请求方式，根据请求方式的不同分别获取请求参数值，这样就可以解决上述问题，但是以后每个Servlet都需要这样写代码，实现起来比较麻烦，这种方案我们不采用\n\n方案二\n\n根据不同的请求方式获取请求参数，获取的内容如下:\n\n\n把获取到的内容进行分割，内容如下:\n\n\n把分割后端数据，存入到一个Map集合中:\n\n\n\n注意:因为参数的值可能是一个，也可能有多个，所以Map的值的类型为String数组。\n基于上述理论，request对象为我们提供了如下方法:\n\n获取所有参数Map集合\nMap&lt;String,String[]&gt; getParameterMap()\n\n根据名称获取参数值（数组）\nString[] getParameterValues(String name)\n\n根据名称获取参数值(单个值)\nString getParameter(String name)\n\n接下来，我们通过案例来把上述的三个方法进行实例演示:\n获取GET方式的所有请求参数\n@WebServlet(&quot;/request02&quot;)public class RequestDemo02 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        System.out.println(&quot;get.....&quot;);        //获取全部参数的Map集合        Map&lt;String, String[]&gt; parameterMap = req.getParameterMap();        for (String key : parameterMap.keySet()) &#123;            System.out.print( key+ &quot;:&quot;);            String[] values = parameterMap.get(key);            for (String value : values) &#123;                System.out.print(value+ &quot; &quot;);            &#125;            System.out.println();        &#125;        //根据key来获取参数值 数组        String[] hobbies = req.getParameterValues(&quot;hobby&quot;);        for (String hobby : hobbies) &#123;            System.out.println(hobby);        &#125;        //根据key获取单个的值        String username = req.getParameter(&quot;username&quot;);        System.out.println(username);    &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;       doGet(req, resp);    &#125;&#125;\n\n\n\n\n\n\n5.3 请求参数乱码问题\n/** * 中文乱码问题解决方案 */@WebServlet(&quot;/req4&quot;)public class RequestDemo4 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        //1. 解决乱码: POST getReader()        //设置字符输入流的编码，设置的字符集要和页面保持一致        request.setCharacterEncoding(&quot;UTF-8&quot;);       //2. 获取username       String username = request.getParameter(&quot;username&quot;);       System.out.println(username);    &#125;    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        this.doGet(request, response);    &#125;&#125;\n\n\nPOST请求和GET请求的参数中如果有中文，后台接收数据就会出现中文乱码问题\n\n\nGET请求在Tomcat8.0以后的版本就不会出现了\n\nPOST请求解决方案是:设置输入流的编码\nrequest.setCharacterEncoding(&quot;UTF-8&quot;);注意:设置的字符集要和页面保持一致\n\n通用方式（GET&#x2F;POST）：需要先解码，再编码\nnew String(username.getBytes(&quot;ISO-8859-1&quot;),&quot;UTF-8&quot;);\n\nURL编码实现方式:\n\n编码:\nURLEncoder.encode(str,&quot;UTF-8&quot;);\n\n解码:\nURLDecoder.decode(s,&quot;ISO-8859-1&quot;);\n\n\n\n5.4 Request请求转发请求转发(forward):一种在服务器内部的资源跳转方式\n\n(1)浏览器发送请求给服务器，服务器中对应的资源A接收到请求\n(2)资源A处理完请求后将请求发给资源B\n(3)资源B处理完后将结果响应给浏览器\n(4)请求从资源A到资源B的过程就叫&#x3D;&#x3D;请求转发&#x3D;&#x3D;\n1.请求转发的实现方式:req.getRequestDispatcher(&quot;资源B路径&quot;).forward(req,resp);\n\n\n@WebServlet(&quot;/req4&quot;)public class RequestDemo04 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException &#123;        System.out.println(&quot;demo04.....&quot;);                req.getRequestDispatcher(&quot;/req5&quot;).forward(req,res);    &#125;    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        doGet(request, response);    &#125;&#125;\n\n@WebServlet(&quot;/req5&quot;)public class RequestDemo05 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException &#123;        System.out.println(&quot;demo05.....&quot;);    &#125;    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        doGet(request, response);    &#125;&#125;\n\n访问http://localhost:8080/request-demo/req4会直接跳转到req5\n2.请求转发资源间共享数据:使用Request对象此处主要解决的问题是把请求从/req5转发到/req6的时候，如何传递数据给/req6。\n需要使用request对象提供的三个方法:\n\n存储数据到request域[范围,数据是存储在request对象]中\nvoid setAttribute(String name,Object o);\n\n根据key获取值\nObject getAttribute(String name);\n\n根据key删除该键值对\nvoid removeAttribute(String name);\n\n修上面的方法\n@WebServlet(&quot;/req4&quot;)public class RequestDemo04 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException &#123;        System.out.println(&quot;demo04.....&quot;);        //储一些数据        req.setAttribute(&quot;name&quot;,&quot;zs&quot;);\t\t//请求转发        req.getRequestDispatcher(&quot;/req5&quot;).forward(req,res);    &#125;    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        doGet(request, response);    &#125;&#125;\n\n@WebServlet(&quot;/req5&quot;)public class RequestDemo05 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException &#123;        System.out.println(&quot;demo05.....&quot;);        System.out.println(req.getAttribute(&quot;name&quot;));    &#125;    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        doGet(request, response);    &#125;&#125;\n\n3.请求转发的特点\n浏览器地址栏路径不发生变化\n虽然后台从/req4转发到/req5,但是浏览器的地址一直是/req4,未发生变化\n\n只能转发到当前服务器的内部资源\n不能从一个服务器通过转发访问另一台服务器\n\n一次请求，可以在转发资源间使用request共享数据\n虽然后台从/req4转发到/req5，但是这个&#x3D;&#x3D;只有一次请求&#x3D;&#x3D;\n\n\n5.3 Response对象Reponse的继承体系和Request的继承体系也非常相似:\n\n5.3.1 Response设置响应数据功能介绍HTTP响应数据总共分为三部分内容，分别是 响应行、响应头、响应体\n\n响应行\n\n对于响应头，比较常用的就是设置响应状态码:\nvoid setStatus(int sc);\n\n\n响应头\n\n\n设置响应头键值对：\nvoid setHeader(String name,String value);\n\n\n响应体\n\n\n\n对于响应体，是通过字符、字节输出流的方式往浏览器写，\n获取字符输出流:\nPrintWriter getWriter();\n\n获取字节输出流\nServletOutputStream getOutputStream();\n\n通过Respones重定向完成一些案例\n5.3.2 Respones请求重定向Response重定向(redirect):一种资源跳转方式。\n\n(1)浏览器发送请求给服务器，服务器中对应的资源A接收到请求\n(2)资源A现在无法处理该请求，就会给浏览器响应一个302的状态码+location的一个访问资源B的路径\n(3)浏览器接收到响应状态码为302就会重新发送请求到location对应的访问地址去访问资源B\n(4)资源B接收到请求后进行处理并最终给浏览器响应结果，这整个过程就叫重定向\n1. 重定向的实现方式:resp.setStatus(302);resp.setHeader(&quot;location&quot;,&quot;资源B的访问路径&quot;);\n\n\n创建ResponseDemo1类\n@WebServlet(&quot;/resp1&quot;)public class ResponseDemo1 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        System.out.println(&quot;resp1....&quot;);    &#125;    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        this.doGet(request, response);    &#125;&#125;\n\n创建ResponseDemo2类\n@WebServlet(&quot;/resp2&quot;)public class ResponseDemo2 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        System.out.println(&quot;resp2....&quot;);    &#125;    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        this.doGet(request, response);    &#125;&#125;\n\n在ResponseDemo1的doGet方法中给前端响应数据\n@WebServlet(&quot;/resp1&quot;)public class ResponseDemo1 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        System.out.println(&quot;resp1....&quot;);        //重定向        //1.设置响应状态码 302        response.setStatus(302);        //2. 设置响应头 Location        response.setHeader(&quot;Location&quot;,&quot;/request-demo/resp2&quot;);    &#125;    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        this.doGet(request, response);    &#125;&#125;\n\n虽然功能已经实现，但是从设置重定向的两行代码来看，会发现除了重定向的地址不一样，其他的内容都是一模一样，所以request对象给我们提供了简化的编写方式为:\nresposne.sendRedirect(&quot;/request-demo/resp2&quot;)\n\n所以第3步中的代码就可以简化为：\n@WebServlet(&quot;/resp1&quot;)public class ResponseDemo1 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        System.out.println(&quot;resp1....&quot;);        //重定向        resposne.sendRedirect(&quot;/request-demo/resp2&quot;)；    &#125;    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        this.doGet(request, response);    &#125;&#125;\n\n2. 重定向的特点\n浏览器地址栏路径发送变化\n可以重定向到任何位置的资源(服务内容、外部均可)\n两次请求，不能在多个资源使用request共享数据\n\n\n以后到底用哪个，还是需要根据具体的业务来决定。\n3. 路径问题问题：转发的时候路径上没有加/request-demo而重定向加了，那么到底什么时候需要加，什么时候不需要加呢?\n\n其实判断的依据很简单，只需要记住下面的规则即可:\n\n浏览器使用:需要加虚拟目录(项目访问路径)\n服务端使用:不需要加虚拟目录\n\n对于转发来说，因为是在服务端进行的，所以不需要加虚拟目录\n对于重定向来说，路径最终是由浏览器来发送请求，就需要添加虚拟目录。\n问题2：在重定向的代码中，/request-demo是固定编码的，如果后期通过Tomcat插件配置了项目的访问路径，那么所有需要重定向的地方都需要重新修改，该如何优化?\n我们可以在代码中动态去获取项目访问的虚拟目录，具体如何获取，我们可以借助前面咱们所学习的request对象中的getContextPath()方法，修改后的代码如下:\n@WebServlet(&quot;/resp1&quot;)public class ResponseDemo1 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        System.out.println(&quot;resp1....&quot;);        //简化方式完成重定向        //动态获取虚拟目录        String contextPath = request.getContextPath();        response.sendRedirect(contextPath+&quot;/resp2&quot;);    &#125;    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        this.doGet(request, response);    &#125;&#125;\n\n重新启动访问测试，功能依然能够实现，此时就可以动态获取项目访问的虚拟路径，从而降低代码的耦合度。\n5.3.3 Response响应字符数据要想将字符数据写回到浏览器，我们需要两个步骤:\n\n通过Response对象获取字符输出流： PrintWriter writer &#x3D; resp.getWriter();\n通过字符输出流写数据: writer.write(“aaa”);\n\n1. 返回一个简单的字符串aaa/** * 响应字符数据：设置字符数据的响应体 */@WebServlet(&quot;/resp3&quot;)public class ResponseDemo3 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        response.setContentType(&quot;text/html;charset=utf-8&quot;);        //1. 获取字符输出流        PrintWriter writer = response.getWriter();\t\t writer.write(&quot;aaa&quot;);    &#125;    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        this.doGet(request, response);    &#125;&#125;\n\n2. 返回一串html字符串，并且能被浏览器解析@WebServlet(&quot;/resp3&quot;)public class ResponseDemo03 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        //获取字符输入流        resp.setContentType(&quot;text/html;charset=UTF-8&quot;);        PrintWriter writer = resp.getWriter();        writer.write(&quot;&lt;h1&gt;你好h1&gt;&quot;);    &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        this.doGet(req, resp);    &#125;&#125;\n\n注意:一次请求响应结束后，response对象就会被销毁掉，所以不要手动关闭流。\n5.3.4 Response响应字节数据要想将字节数据写回到浏览器，我们需要两个步骤:\n\n通过Response对象获取字节输出流：ServletOutputStream outputStream &#x3D; resp.getOutputStream();\n\n通过字节输出流写数据: outputStream.write(字节数据);\n\n\n1. 返回一个图片文件到浏览器@WebServlet(&quot;/resp4&quot;)public class ResponseDemo04 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        //获取文件        FileInputStream fs = new FileInputStream(&quot;D:\\\\a.png&quot;);        //获取字节输入流        ServletOutputStream os = resp.getOutputStream();        //完成流的Copy        //以后不会这么写        byte[] buffer = new byte[1024];        int len = 0;        while ((len = fs.read(buffer))!= -1)&#123;            os.write(buffer, 0, len);        &#125;        fs.close();    &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        this.doGet(req, resp);    &#125;&#125;\n\n上述代码中，对于流的copy的代码还是比较复杂的，所以我们可以使用别人提供好的方法来简化代码的开发，具体的步骤是:\n\npom.xml添加依赖\n&lt;dependency&gt;    &lt;groupId&gt;commons-io&lt;/groupId&gt;    &lt;artifactId&gt;commons-io&lt;/artifactId&gt;    &lt;version&gt;2.6&lt;/version&gt;&lt;/dependency&gt;\n\n调用工具类方法\n//fis:输入流//os:输出流IOUtils.copy(fis,os);\n\n优化后的代码:\n@WebServlet(&quot;/resp4&quot;)public class ResponseDemo04 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        //获取文件        FileInputStream fs = new FileInputStream(&quot;D:\\\\a.png&quot;);        //获取字节输入流        ServletOutputStream os = resp.getOutputStream();                IOUtils.copy(fs, os);                fs.close();    &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        this.doGet(req, resp);    &#125;&#125;\n\n5.4 用户注册登录案例5.4.1 用户注册登录案例1. 需求分析\n\n用户在登录页面输入用户名和密码，提交请求给LoginServlet\n在LoginServlet中接收请求和数据[用户名和密码]\n在LoginServlt中通过Mybatis实现调用UserMapper来根据用户名和密码查询数据库表\n将查询的结果封装到User对象中进行返回\n在LoginServlet中判断返回的User对象是否为null\n如果为nul，说明根据用户名和密码没有查询到用户，则登录失败，返回”登录失败”数据给前端\n如果不为null,则说明用户存在并且密码正确，则登录成功，返回”登录成功”数据给前端\n\n2.  环境准备\n准备数据库\n\n   -- 创建用户表CREATE TABLE tb_user(\tid int primary key auto_increment,\tusername varchar(20) unique,\tpassword varchar(32));-- 添加数据INSERT INTO tb_user(username,password) values(&#x27;zhangsan&#x27;,&#x27;123&#x27;),(&#x27;lisi&#x27;,&#x27;234&#x27;);SELECT * FROM tb_user;\n\n\n在java里创建pojo包，包里创建User类\npublic class User &#123;    private Integer id;    private String username;    private String password;    public Integer getId() &#123;        return id;    &#125;    public void setId(Integer id) &#123;        this.id = id;    &#125;    public String getUsername() &#123;        return username;    &#125;    public void setUsername(String username) &#123;        this.username = username;    &#125;    public String getPassword() &#123;        return password;    &#125;    public void setPassword(String password) &#123;        this.password = password;    &#125;    @Override    public String toString() &#123;        return &quot;User&#123;&quot; +                &quot;id=&quot; + id +                &quot;, username=&#x27;&quot; + username + &#x27;\\&#x27;&#x27; +                &quot;, password=&#x27;&quot; + password + &#x27;\\&#x27;&#x27; +                &#x27;&#125;&#x27;;    &#125;&#125;\n\n在项目的pom.xml导入Mybatis和Mysql驱动坐标\n&lt;!-- 导入mybatis --&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.mybatis&lt;/groupId&gt;      &lt;artifactId&gt;mybatis&lt;/artifactId&gt;      &lt;version&gt;3.5.10&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- 导入mysql驱动 --&gt;    &lt;dependency&gt;      &lt;groupId&gt;mysql&lt;/groupId&gt;      &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;      &lt;version&gt;8.0.29&lt;/version&gt;    &lt;/dependency&gt;\n\n创建mybatis-config.xml核心配置文件，UserMapper.xml映射文件,UserMapper接口\nmybatis-config.xml核心配置文件\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;!--起别名--&gt;    &lt;typeAliases&gt;        &lt;package name=&quot;com.itheima.pojo&quot;/&gt;    &lt;/typeAliases&gt;    &lt;environments default=&quot;development&quot;&gt;        &lt;environment id=&quot;development&quot;&gt;            &lt;transactionManager type=&quot;JDBC&quot;/&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///db01?useSSL=false&amp;amp;useServerPrepStmts=true&quot;/&gt;                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;                &lt;property name=&quot;password&quot; value=&quot;abcd1234&quot;/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;mappers&gt;        &lt;!--扫描mapper--&gt;        &lt;package name=&quot;com.ithm.mapper&quot;/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;\n\nUserMapper.xml映射文件拷贝到resources目录下\n在resources下创建UserMapper.xml的目录时，要使用&#x2F;分割 com&#x2F;login&#x2F;UserMapper.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.ithm.mapper.UserMapper&quot;&gt;&lt;/mapper&gt;\n\nUserMapper接口\npublic interface UserMapper &#123;    //编写mybatis&#125;\n\n3. 代码实现\n在UserMapper接口中提供一个根据用户名和密码查询用户对象的方法\npublic interface UserMapper &#123;     /**     * @Description 根据用户名和密码来查询用户     * @param username     * @param password     * @return     */    @Select(&quot;select * from tb_user where username = #&#123;username&#125; and password = #&#123;password&#125;&quot;)    User getUser(@Param(&quot;username&quot;) String username, @Param(&quot;password&quot;) String password);&#125;\n\n@Param注解的作用:用于传递参数,是方法的参数可以与SQL中的字段名相对应。\n\n修改loign.html\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;login&lt;/title&gt;    &lt;link href=&quot;css/login.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;loginDiv&quot;&gt;    &lt;form action=&quot;/request-demo/loginServlet&quot; method=&quot;post&quot; id=&quot;form&quot;&gt;        &lt;h1 id=&quot;loginMsg&quot;&gt;LOGIN IN&lt;/h1&gt;        &lt;p&gt;Username:&lt;input id=&quot;username&quot; name=&quot;username&quot; type=&quot;text&quot;&gt;&lt;/p&gt;        &lt;p&gt;Password:&lt;input id=&quot;password&quot; name=&quot;password&quot; type=&quot;password&quot;&gt;&lt;/p&gt;        &lt;div id=&quot;subDiv&quot;&gt;            &lt;input type=&quot;submit&quot; class=&quot;button&quot; value=&quot;login up&quot;&gt;            &lt;input type=&quot;reset&quot; class=&quot;button&quot; value=&quot;reset&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;            &lt;a href=&quot;register.html&quot;&gt;没有账号？点击注册&lt;/a&gt;        &lt;/div&gt;    &lt;/form&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n编写LoginServlet\n@WebServlet(&quot;/loginServlet&quot;)public class LoginServlet extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        //1. 接收用户名和密码        String username = request.getParameter(&quot;username&quot;);        String password = request.getParameter(&quot;password&quot;);        //2. 调用MyBatis完成查询        //2.1 获取SqlSessionFactory对象        String resource = &quot;mybatis-config.xml&quot;;        InputStream inputStream = Resources.getResourceAsStream(resource);        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);        //2.2 获取SqlSession对象        SqlSession sqlSession = sqlSessionFactory.openSession();        //2.3 获取Mapper        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);        //2.4 调用方法        User user = userMapper.select(username, password);        //2.5 释放资源        sqlSession.close();        //获取字符输出流，并设置content type        response.setContentType(&quot;text/html;charset=utf-8&quot;);        PrintWriter writer = response.getWriter();        //3. 判断user释放为null        if(user != null)&#123;            // 登陆成功            writer.write(&quot;登陆成功&quot;);        &#125;else &#123;            // 登陆失败            writer.write(&quot;登陆失败&quot;);        &#125;    &#125;    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        this.doGet(request, response);    &#125;&#125;\n\n启动服务器测试\n\n\n如果用户名和密码输入错误，则\n\n 如果用户名和密码输入正确，则\n\n5.4.2 用户注册1. 需求分析\n\n用户在注册页面输入用户名和密码，提交请求给RegisterServlet\n在RegisterServlet中接收请求和数据[用户名和密码]\n在RegisterServlet中通过Mybatis实现调用UserMapper来根据用户名查询数据库表\n将查询的结果封装到User对象中进行返回\n在RegisterServlet中判断返回的User对象是否为null\n如果为nul，说明根据用户名可用，则调用UserMapper来实现添加用户\n如果不为null,则说明用户不可以，返回”用户名已存在”数据给前端\n\n2. 代码实现\n编写UserMapper提供根据用户名查询用户数据方法和添加用户方法\n/** * @Description 根据用户名查找用户 * @param username * @return */   @Select(&quot;select * from tb_user where username = #&#123;username&#125;&quot;)User getUserByUsername(String username);      /** * @Description 添加用户 * @param username * @param password */@Insert(&quot;insert into tb_user values (null,#&#123;username&#125;, #&#123;password&#125;)&quot;)void addUser(@Param(&quot;username&quot;) String username, @Param(&quot;password&quot;) String password);\n\n修改register.html\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;欢迎注册&lt;/title&gt;    &lt;link href=&quot;css/register.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;form-div&quot;&gt;    &lt;div class=&quot;reg-content&quot;&gt;        &lt;h1&gt;欢迎注册&lt;/h1&gt;        &lt;span&gt;已有帐号？&lt;/span&gt; &lt;a href=&quot;login.html&quot;&gt;登录&lt;/a&gt;    &lt;/div&gt;    &lt;form id=&quot;reg-form&quot; action=&quot;/request-demo/registerServlet&quot; method=&quot;post&quot;&gt;        &lt;table&gt;            &lt;tr&gt;                &lt;td&gt;用户名&lt;/td&gt;                &lt;td class=&quot;inputs&quot;&gt;                    &lt;input name=&quot;username&quot; type=&quot;text&quot; id=&quot;username&quot;&gt;                    &lt;br&gt;                    &lt;span id=&quot;username_err&quot; class=&quot;err_msg&quot; style=&quot;display: none&quot;&gt;用户名不太受欢迎&lt;/span&gt;                &lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td&gt;密码&lt;/td&gt;                &lt;td class=&quot;inputs&quot;&gt;                    &lt;input name=&quot;password&quot; type=&quot;password&quot; id=&quot;password&quot;&gt;                    &lt;br&gt;                    &lt;span id=&quot;password_err&quot; class=&quot;err_msg&quot; style=&quot;display: none&quot;&gt;密码格式有误&lt;/span&gt;                &lt;/td&gt;            &lt;/tr&gt;        &lt;/table&gt;        &lt;div class=&quot;buttons&quot;&gt;            &lt;input value=&quot;注 册&quot; type=&quot;submit&quot; id=&quot;reg_btn&quot;&gt;        &lt;/div&gt;        &lt;br class=&quot;clear&quot;&gt;    &lt;/form&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n创建RegisterServlet类\n@WebServlet(&quot;/registerServlet&quot;)public class RegisterServlet extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        //获取用户名        String username = request.getParameter(&quot;username&quot;);        String password = request.getParameter(&quot;password&quot;);        //调用mybatis来查询用户        //获取sqlSessionFactory对象        String resource = &quot;mybatis-config.xml&quot;;        InputStream inputStream = Resources.getResourceAsStream(resource);        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);        SqlSession sqlSession = sqlSessionFactory.openSession();        //获取map        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);        //调用方法        User newUserName =  userMapper.getUserByUsername(username);        response.setContentType(&quot;text/html; charset=UTF-8&quot;);        PrintWriter writer = response.getWriter();        if (newUserName == null)&#123;            userMapper.addUser(username,password);            //还得提交事务。。。。。。            sqlSession.commit();            if (userMapper.getUserByUsername(username) != null)&#123;                writer.write(&quot;&lt;h1&gt;添加成功&lt;/h1&gt;&quot;);            &#125;        &#125;else&#123;            writer.write(&quot;&lt;h1&gt;用户已存在无法注册&lt;/h1&gt;&quot;);        &#125;        //释放资源        sqlSession.close();    &#125;    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        doGet(request, response);    &#125;&#125;\n\n启动服务器进行测试\n如果测试成功，则在数据库中就能查看到新注册的数据\n如果用户已经存在，则在页面上展示 用户名已存在 的提示信息\n\n\n5.4.3 SqlSessionFactory工具类抽取上面两个功能已经实现，但是在写Servlet的时候，因为需要使用Mybatis来完成数据库的操作，所以对于Mybatis的基础操作就出现了些重复代码，如下\nString resource = &quot;mybatis-config.xml&quot;;InputStream inputStream = Resources.getResourceAsStream(resource);SqlSessionFactory sqlSessionFactory = new \tSqlSessionFactoryBuilder().build(inputStream);\n\n有了这些重复代码就会造成一些问题:\n\n重复代码不利于后期的维护\nSqlSessionFactory工厂类进行重复创建\n就相当于每次买手机都需要重新创建一个手机生产工厂来给你制造一个手机一样，资源消耗非常大但性能却非常低。所以这么做是不允许的。\n\n\n\n解决方案\n\n代码重复可以抽取工具类\n对指定代码只需要执行一次可以使用静态代码块\n\npublic class SqlSessionFactoryUtils &#123;    private static SqlSessionFactory sqlSessionFactory;    static &#123;        //静态代码块会随着类的加载而自动执行，且只执行一次        try &#123;            String resource = &quot;mybatis-config.xml&quot;;            InputStream inputStream = Resources.getResourceAsStream(resource);            sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;    public static SqlSessionFactory getSqlSessionFactory()&#123;        return sqlSessionFactory;    &#125;&#125;\n\n工具类抽取以后，以后在对Mybatis的SqlSession进行操作的时候，就可以直接使用\nSqlSessionFactory sqlSessionFactory =SqlSessionFactoryUtils.getSqlSessionFactory();\n\n这样就可以很好的解决上面所说的代码重复和重复创建工厂导致性能低的问题了。\n6. JSP6.1 概述JSP（全称：Java Server Pages）：Java 服务端页面。是一种动态的网页技术，其中既可以定义 HTML、JS、CSS等静态内容，还可以定义 Java代码的动态内容，也就是 JSP = HTML + Java。\nJSP 作用：简化开发，避免了在Servlet中直接输出HTML标签。\n6.2 快速入门1.搭建环境创建一个maven的web项目pom.xml 文件内容如下：\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;org.example&lt;/groupId&gt;    &lt;artifactId&gt;jsp-demo&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;packaging&gt;war&lt;/packaging&gt;    &lt;properties&gt;        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;    &lt;/properties&gt;    &lt;dependencies&gt;      &lt;dependency&gt;            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;            &lt;version&gt;3.1.0&lt;/version&gt;            &lt;scope&gt;provided&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;                &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;                &lt;version&gt;2.2&lt;/version&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;\n\n2. 导入JSP依赖在 dependencies 标签中导入 JSP 的依赖，如下\n&lt;dependency&gt;    &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;    &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;    &lt;version&gt;2.2&lt;/version&gt;    &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;\n\n该依赖的 scope 必须设置为 provided，因为 tomcat 中有这个jar包了，所以在打包时我们是不希望将该依赖打进到我们工程的war包中\n3.创建JSP页面在webapp上创建一个名为hello.jsp的页面\n在 hello.jsp 页面中书写 HTML 标签和 Java 代码，如下\n&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;hello jsp&lt;/h1&gt;    &lt;%        System.out.println(&quot;hello,jsp~&quot;);    %&gt;&lt;/body&gt;&lt;/html&gt;\n\n4. 测试启动服务器并在浏览器地址栏输入 &#96;http://localhost:8080/jsp-demo/hello.jsp\n就能访问到jsp了\n6.3 JSP原理\nJSP 本质上就是一个 Servlet。\n\n浏览器第一次访问 hello.jsp 页面\ntomcat 会将 hello.jsp 转换为名为 hello_jsp.java 的一个 Servlet\ntomcat 再将转换的 servlet 编译成字节码文件 hello_jsp.class\ntomcat 会执行该字节码文件，向外提供服务\n\n6.4  JSP 脚本JSP脚本用于在 JSP页面内定义 Java代码。在之前的入门案例中我们就在 JSP 页面定义的 Java 代码就是 JSP 脚本。\nJSP 脚本有如下三个分类：\n\n&lt;%…%&gt;：内容会直接放到_jspService()方法之中\n&lt;%&#x3D;…%&gt;：内容会放到out.print()中，作为out.print()的参数\n&lt;%!…%&gt;：内容会放到_jspService()方法之外，被类直接包含\n\n代码演示：\n在 hello.jsp 中书写\n&lt;%    System.out.println(&quot;hello,jsp~&quot;);    int i = 3;%&gt;\n\n通过浏览器访问 hello.jsp 后，查看转换的 hello_jsp.java 文件，i 变量定义在了 _jspService() 方法中\n\n在 hello.jsp 中书写\n&lt;%=&quot;hello&quot;%&gt;&lt;%=i%&gt;\n\n通过浏览器访问 hello.jsp 后，查看转换的 hello_jsp.java 文件，该脚本的内容被放在了 out.print() 中，作为参数\n\n在 hello.jsp 中书写\n&lt;%!    void  show()&#123;&#125;\tString name = &quot;zhangsan&quot;;%&gt;\n\n通过浏览器访问 hello.jsp 后，查看转换的 hello_jsp.java 文件，该脚本的内容被放在了成员位置\n\n案例使用JSP脚本展示品牌数据\n\n在该案例中数据不从数据库中查询，而是在 JSP 页面上写死\n实现\n创建pojo包，包里创建Brand.java文件\n/** * 品牌实体类 */public class Brand &#123;    // id 主键    private Integer id;    // 品牌名称    private String brandName;    // 企业名称    private String companyName;    // 排序字段    private Integer ordered;    // 描述信息    private String description;    // 状态：0：禁用  1：启用    private Integer status;    public Brand() &#123;    &#125;    public Brand(Integer id, String brandName, String companyName, String description) &#123;        this.id = id;        this.brandName = brandName;        this.companyName = companyName;        this.description = description;    &#125;    public Brand(Integer id, String brandName, String companyName, Integer ordered, String description, Integer status) &#123;        this.id = id;        this.brandName = brandName;        this.companyName = companyName;        this.ordered = ordered;        this.description = description;        this.status = status;    &#125;    public Integer getId() &#123;        return id;    &#125;    public void setId(Integer id) &#123;        this.id = id;    &#125;    public String getBrandName() &#123;        return brandName;    &#125;    public void setBrandName(String brandName) &#123;        this.brandName = brandName;    &#125;    public String getCompanyName() &#123;        return companyName;    &#125;    public void setCompanyName(String companyName) &#123;        this.companyName = companyName;    &#125;    public Integer getOrdered() &#123;        return ordered;    &#125;    public void setOrdered(Integer ordered) &#123;        this.ordered = ordered;    &#125;    public String getDescription() &#123;        return description;    &#125;    public void setDescription(String description) &#123;        this.description = description;    &#125;    public Integer getStatus() &#123;        return status;    &#125;    public void setStatus(Integer status) &#123;        this.status = status;    &#125;    @Override    public String toString() &#123;        return &quot;Brand&#123;&quot; +                &quot;id=&quot; + id +                &quot;, brandName=&#x27;&quot; + brandName + &#x27;\\&#x27;&#x27; +                &quot;, companyName=&#x27;&quot; + companyName + &#x27;\\&#x27;&#x27; +                &quot;, ordered=&quot; + ordered +                &quot;, description=&#x27;&quot; + description + &#x27;\\&#x27;&#x27; +                &quot;, status=&quot; + status +                &#x27;&#125;&#x27;;    &#125;&#125;\n\n在项目的 webapp 中创建 brand.jsp ，并将 brand.html页面中的内容拷贝过来。brand.jsp 内容如下\n&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;button&quot; value=&quot;新增&quot;&gt;&lt;br&gt;&lt;hr&gt;    &lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; width=&quot;800&quot;&gt;        &lt;tr&gt;            &lt;th&gt;序号&lt;/th&gt;            &lt;th&gt;品牌名称&lt;/th&gt;            &lt;th&gt;企业名称&lt;/th&gt;            &lt;th&gt;排序&lt;/th&gt;            &lt;th&gt;品牌介绍&lt;/th&gt;            &lt;th&gt;状态&lt;/th&gt;            &lt;th&gt;操作&lt;/th&gt;        &lt;/tr&gt;        &lt;tr align=&quot;center&quot;&gt;            &lt;td&gt;1&lt;/td&gt;            &lt;td&gt;三只松鼠&lt;/td&gt;            &lt;td&gt;三只松鼠&lt;/td&gt;            &lt;td&gt;100&lt;/td&gt;            &lt;td&gt;三只松鼠，好吃不上火&lt;/td&gt;            &lt;td&gt;启用&lt;/td&gt;            &lt;td&gt;&lt;a href=&quot;#&quot;&gt;修改&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;删除&lt;/a&gt;&lt;/td&gt;        &lt;/tr&gt;        &lt;tr align=&quot;center&quot;&gt;            &lt;td&gt;2&lt;/td&gt;            &lt;td&gt;优衣库&lt;/td&gt;            &lt;td&gt;优衣库&lt;/td&gt;            &lt;td&gt;10&lt;/td&gt;            &lt;td&gt;优衣库，服适人生&lt;/td&gt;            &lt;td&gt;禁用&lt;/td&gt;            &lt;td&gt;&lt;a href=&quot;#&quot;&gt;修改&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;删除&lt;/a&gt;&lt;/td&gt;        &lt;/tr&gt;        &lt;tr align=&quot;center&quot;&gt;            &lt;td&gt;3&lt;/td&gt;            &lt;td&gt;小米&lt;/td&gt;            &lt;td&gt;小米科技有限公司&lt;/td&gt;            &lt;td&gt;1000&lt;/td&gt;            &lt;td&gt;为发烧而生&lt;/td&gt;            &lt;td&gt;启用&lt;/td&gt;            &lt;td&gt;&lt;a href=&quot;#&quot;&gt;修改&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;删除&lt;/a&gt;&lt;/td&gt;        &lt;/tr&gt;    &lt;/table&gt;&lt;/body&gt;&lt;/html&gt;\n\n在 brand.jsp 中准备一些数据\n&lt;%    // 查询数据库    List&lt;Brand&gt; brands = new ArrayList&lt;Brand&gt;();    brands.add(new Brand(1,&quot;三只松鼠&quot;,&quot;三只松鼠&quot;,100,&quot;三只松鼠，好吃不上火&quot;,1));    brands.add(new Brand(2,&quot;优衣库&quot;,&quot;优衣库&quot;,200,&quot;优衣库，服适人生&quot;,0));    brands.add(new Brand(3,&quot;小米&quot;,&quot;小米科技有限公司&quot;,1000,&quot;为发烧而生&quot;,1));%&gt;\n\n将 brand.jsp 页面中的 table 标签中的数据改为动态的\n&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; width=&quot;800&quot;&gt;    &lt;tr&gt;        &lt;th&gt;序号&lt;/th&gt;        &lt;th&gt;品牌名称&lt;/th&gt;        &lt;th&gt;企业名称&lt;/th&gt;        &lt;th&gt;排序&lt;/th&gt;        &lt;th&gt;品牌介绍&lt;/th&gt;        &lt;th&gt;状态&lt;/th&gt;        &lt;th&gt;操作&lt;/th&gt;    &lt;/tr&gt;        &lt;%     for (int i = 0; i &lt; brands.size(); i++) &#123;         //获取集合中的 每一个 Brand 对象         Brand brand = brands.get(i);    %&gt;    \t &lt;tr align=&quot;center&quot;&gt;            &lt;td&gt;1&lt;/td&gt;            &lt;td&gt;三只松鼠&lt;/td&gt;            &lt;td&gt;三只松鼠&lt;/td&gt;            &lt;td&gt;100&lt;/td&gt;            &lt;td&gt;三只松鼠，好吃不上火&lt;/td&gt;            &lt;td&gt;启用&lt;/td&gt;            &lt;td&gt;&lt;a href=&quot;#&quot;&gt;修改&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;删除&lt;/a&gt;&lt;/td&gt;        &lt;/tr&gt;    &lt;%     &#125;    %&gt;   &lt;/table&gt;\n\n上面代码中的 td 标签中的数据都需要是动态的，所以还需要改进\n&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; width=&quot;800&quot;&gt;    &lt;tr&gt;        &lt;th&gt;序号&lt;/th&gt;        &lt;th&gt;品牌名称&lt;/th&gt;        &lt;th&gt;企业名称&lt;/th&gt;        &lt;th&gt;排序&lt;/th&gt;        &lt;th&gt;品牌介绍&lt;/th&gt;        &lt;th&gt;状态&lt;/th&gt;        &lt;th&gt;操作&lt;/th&gt;    &lt;/tr&gt;        &lt;%     for (int i = 0; i &lt; brands.size(); i++) &#123;         //获取集合中的 每一个 Brand 对象         Brand brand = brands.get(i);    %&gt;    \t &lt;tr align=&quot;center&quot;&gt;            &lt;td&gt;&lt;%=brand.getId()%&gt;&lt;/td&gt;            &lt;td&gt;&lt;%=brand.getBrandName()%&gt;&lt;/td&gt;            &lt;td&gt;&lt;%=brand.getCompanyName()%&gt;&lt;/td&gt;            &lt;td&gt;&lt;%=brand.getOrdered()%&gt;&lt;/td&gt;            &lt;td&gt;&lt;%=brand.getDescription()%&gt;&lt;/td&gt;            &lt;td&gt;&lt;%=brand.getStatus() == 1 ? &quot;启用&quot;:&quot;禁用&quot;%&gt;&lt;/td&gt;            &lt;td&gt;&lt;a href=&quot;#&quot;&gt;修改&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;删除&lt;/a&gt;&lt;/td&gt;        &lt;/tr&gt;    &lt;%     &#125;    %&gt;   &lt;/table&gt;\n\n成品\n&lt;%@ page import=&quot;com.ithm.pojo.Brand&quot; %&gt;&lt;%@ page import=&quot;java.util.List&quot; %&gt;&lt;%@ page import=&quot;java.util.ArrayList&quot;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot;  isELIgnored=&quot;false&quot; %&gt;&lt;% List&lt;Brand&gt; brands = new ArrayList&lt;Brand&gt;();    brands.add(new Brand(1, &quot;三只松鼠&quot;, &quot;三只松鼠&quot;, 100, &quot;三只松鼠，好吃不上火&quot;, 1));    brands.add(new Brand(2, &quot;优衣库&quot;, &quot;优衣库&quot;, 200, &quot;优衣库，服适人生&quot;, 0));    brands.add(new Brand(3, &quot;小米&quot;, &quot;小米科技有限公司&quot;, 1000, &quot;为发烧而生&quot;, 1)); %&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;button&quot; value=&quot;新增&quot;&gt;&lt;br&gt;&lt;hr&gt;&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; width=&quot;800&quot;&gt;    &lt;tr&gt;        &lt;th&gt;序号&lt;/th&gt;        &lt;th&gt;品牌名称&lt;/th&gt;        &lt;th&gt;企业名称&lt;/th&gt;        &lt;th&gt;排序&lt;/th&gt;        &lt;th&gt;品牌介绍&lt;/th&gt;        &lt;th&gt;状态&lt;/th&gt;        &lt;th&gt;操作&lt;/th&gt;    &lt;/tr&gt;    &lt;%        for (int i = 0; i &lt; brands.size(); i++) &#123;            Brand brand = brands.get(i);    %&gt;    &lt;tr align=&quot;center&quot;&gt;        &lt;td&gt;&lt;%= brand.getId()%&gt; &lt;/td&gt;        &lt;td&gt;&lt;%= brand.getBrandName()%&gt; &lt;/td&gt;        &lt;td&gt;&lt;%= brand.getCompanyName()%&gt;&lt;/td&gt;        &lt;td&gt;&lt;%= brand.getOrdered()%&gt; &lt;/td&gt;        &lt;td&gt;&lt;%= brand.getDescription()%&gt;&lt;/td&gt;        &lt;td&gt;&lt;%=  brand.getStatus()==1?&quot;已启用&quot;:&quot;已禁用&quot;%&gt;&lt;/td&gt;        &lt;td&gt;&lt;a href=&quot;#&quot;&gt;修改&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;删除&lt;/a&gt;&lt;/td&gt;    &lt;/tr&gt;   &lt;%        &#125;    %&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;\n\n在浏览器地址栏输入 http://localhost:8080/jsp-demo/brand.jsp 即可访问了\nJSP缺点\n书写麻烦：特别是复杂的页面\n阅读麻烦\n复杂度高：运行需要依赖于各种环境，JRE，JSP容器，JavaEE…\n占内存和磁盘：JSP会自动生成.java和.class文件占磁盘，运行的是.class文件占内存\n调试困难：出错后，需要找到自动生成的.java文件进行调试\n不利于团队协作：前端人员不会 Java，后端人员不精 HTML\n\n由于上述的问题， JSP 已逐渐退出历史舞台，以后开发更多的是使用 HTML +  Ajax 来替代\n6.5 EL表达式1.概述EL（全称Expression Language ）表达式语言，用于简化 JSP 页面内的 Java 代码。\nEL 表达式的主要作用是 &#x3D;&#x3D;获取数据&#x3D;&#x3D;。其实就是从域对象中获取数据，然后将数据展示在页面上。\n而 EL 表达式的语法也比较简单，&#x3D;&#x3D;${expression}&#x3D;&#x3D; 。例如：${brands} 就是获取域中存储的 key 为 brands 的数据。\n2. 代码演示定义servlet，在 servlet 中封装一些数据并存储到 request 域对象中并转发到 el-demo.jsp 页面。\npackage com.ithm.web;import javax.servlet.*;import javax.servlet.http.*;import javax.servlet.annotation.*;import java.io.IOException;import java.util.ArrayList;import java.util.List;@WebServlet(&quot;/demo1&quot;)public class ServletDemo1 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        //1. 准备数据        List&lt;Brand&gt; brands = new ArrayList&lt;Brand&gt;();        brands.add(new Brand(1,&quot;三只松鼠&quot;,&quot;三只松鼠&quot;,100,&quot;三只松鼠，好吃不上火&quot;,1));        brands.add(new Brand(2,&quot;优衣库&quot;,&quot;优衣库&quot;,200,&quot;优衣库，服适人生&quot;,0));        brands.add(new Brand(3,&quot;小米&quot;,&quot;小米科技有限公司&quot;,1000,&quot;为发烧而生&quot;,1));        //2. 存储到request域中        request.setAttribute(&quot;brands&quot;,brands);        //3. 转发到 el-demo.jsp        request.getRequestDispatcher(&quot;el-jsp&quot;).forward(request,response);    &#125;    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        this.doGet(request, response);    &#125;&#125;\n\n在 el-demo.jsp 中通过 EL表达式 获取数据\n&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    $&#123;brands&#125;&lt;/body&gt;&lt;/html&gt;\n\n在浏览器的地址栏输入 http://localhost:8080/jsp-demo/demo1 ，页面效果如下\n\n3. 域对象JavaWeb中有四大域对象，分别是：\n\npage：当前页面有效\nrequest：当前请求有效\nsession：当前会话有效\napplication：当前应用有效\n\nel 表达式获取数据，会依次从这4个域中寻找，直到找到为止。而这四个域对象的作用范围如下图所示\n\n例如： ${brands}，el 表达式获取数据，会先从page域对象中获取数据，如果没有再到 requet 域对象中获取数据，如果再没有再到 session 域对象中获取，如果还没有才会到 application 中获取数据。\n6.6 JSTL标签1. 概述JSP标准标签库(Jsp Standarded Tag Library) ，使用标签取代JSP页面上的Java代码。如下代码就是JSTL标签\n&lt;c:if test=&quot;$&#123;flag == 1&#125;&quot;&gt;    男&lt;/c:if&gt;&lt;c:if test=&quot;$&#123;flag == 2&#125;&quot;&gt;    女&lt;/c:if&gt;\n\nJSTL 提供了很多标签，如下图\n\nJSTL 使用也是比较简单的，分为如下步骤：\n\n导入坐标\n&lt;dependency&gt;    &lt;groupId&gt;jstl&lt;/groupId&gt;    &lt;artifactId&gt;jstl&lt;/artifactId&gt;    &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;taglibs&lt;/groupId&gt;    &lt;artifactId&gt;standard&lt;/artifactId&gt;    &lt;version&gt;1.1.2&lt;/version&gt;&lt;/dependency&gt;\n\n在JSP页面上引入JSTL标签库\n&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt; \n\n使用标签\n\n\n2. if标签&lt;c:if&gt;：相当于 if 判断\n属性：test，用于定义条件表达式\n&lt;c:if test=&quot;$&#123;flag == 1&#125;&quot;&gt;    男&lt;/c:if&gt;&lt;c:if test=&quot;$&#123;flag == 2&#125;&quot;&gt;    女&lt;/c:if&gt;\n\n3. forEach 标签&lt;c:forEach&gt;：相当于 for 循环。java中有增强for循环和普通for循环，JSTL 中的 &lt;c:forEach&gt; 也有两种用法\n用法一类似于 Java 中的增强for循环。涉及到的 &lt;c:forEach&gt; 中的属性如下\n\nitems：被遍历的容器\n\nvar：遍历产生的临时变量\n\nvarStatus：遍历状态对象\n\n\n&lt;c:forEach items=&quot;$&#123;brands&#125;&quot; var=&quot;brand&quot;&gt;    &lt;tr align=&quot;center&quot;&gt;        &lt;td&gt;$&#123;brand.id&#125;&lt;/td&gt;        &lt;td&gt;$&#123;brand.brandName&#125;&lt;/td&gt;        &lt;td&gt;$&#123;brand.companyName&#125;&lt;/td&gt;        &lt;td&gt;$&#123;brand.description&#125;&lt;/td&gt;    &lt;/tr&gt;&lt;/c:forEach&gt;\n\n上面代码，是从域对象中获取名为 brands 数据，该数据是一个集合；遍历遍历，并给该集合中的每一个元素起名为 brand，是 Brand对象。在循环里面使用 EL表达式获取每一个Brand对象的属性值\n代码演示 \n\nservlet 还是使用之前的名为 ServletDemo1 。\n\n定义名为 jstl-foreach.jsp 页面，内容如下：\n&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;button&quot; value=&quot;新增&quot;&gt;&lt;br&gt;&lt;hr&gt;&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; width=&quot;800&quot;&gt;    &lt;tr&gt;        &lt;th&gt;序号&lt;/th&gt;        &lt;th&gt;品牌名称&lt;/th&gt;        &lt;th&gt;企业名称&lt;/th&gt;        &lt;th&gt;排序&lt;/th&gt;        &lt;th&gt;品牌介绍&lt;/th&gt;        &lt;th&gt;状态&lt;/th&gt;        &lt;th&gt;操作&lt;/th&gt;    &lt;/tr&gt;    &lt;c:forEach items=&quot;$&#123;brands&#125;&quot; var=&quot;brand&quot; varStatus=&quot;status&quot;&gt;        &lt;tr align=&quot;center&quot;&gt;            &lt;%--&lt;td&gt;$&#123;brand.id&#125;&lt;/td&gt;--%&gt;            &lt;td&gt;$&#123;status.count&#125;&lt;/td&gt;            &lt;td&gt;$&#123;brand.brandName&#125;&lt;/td&gt;            &lt;td&gt;$&#123;brand.companyName&#125;&lt;/td&gt;            &lt;td&gt;$&#123;brand.ordered&#125;&lt;/td&gt;            &lt;td&gt;$&#123;brand.description&#125;&lt;/td&gt;            &lt;c:if test=&quot;$&#123;brand.status == 1&#125;&quot;&gt;                &lt;td&gt;启用&lt;/td&gt;            &lt;/c:if&gt;            &lt;c:if test=&quot;$&#123;brand.status != 1&#125;&quot;&gt;                &lt;td&gt;禁用&lt;/td&gt;            &lt;/c:if&gt;            &lt;td&gt;&lt;a href=&quot;#&quot;&gt;修改&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;删除&lt;/a&gt;&lt;/td&gt;        &lt;/tr&gt;    &lt;/c:forEach&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;\n\n用法二类似于 Java 中的普通for循环。涉及到的 &lt;c:forEach&gt; 中的属性如下\n\nbegin：开始数\n\nend：结束数\n\nstep：步长\n\n\n从0循环到10，变量名是 i ，每次自增1\n&lt;c:forEach begin=&quot;0&quot; end=&quot;10&quot; step=&quot;1&quot; var=&quot;i&quot;&gt;    $&#123;i&#125;&lt;/c:forEach&gt;\n\n6.7 MVC模式1. 概述MVC 是一种分层开发的模式，其中：\n\nM：Model，业务模型，处理业务\nV：View，视图，界面展示\nC：Controller，控制器，处理请求，调用模型和视图\n\n\nMVC 好处：\n\n职责单一，互不影响。每个角色做它自己的事，各司其职。\n\n有利于分工协作。\n\n有利于组件重用\n\n\n2. 三层架构三层架构是将我们的项目分成了三个层面，分别是 表现层、业务逻辑层、数据访问层。\n\n\n数据访问层：对数据库的CRUD基本操作\n业务逻辑层：对业务逻辑进行封装，组合数据访问层层中基本功能，形成复杂的业务逻辑功能。例如 注册业务功能 ，我们会先调用 数据访问层 的 selectByName() 方法判断该用户名是否存在，如果不存在再调用 数据访问层 的 insert() 方法进行数据的添加操作\n表现层：接收请求，封装数据，调用业务逻辑层，响应数据\n\n而整个流程是，浏览器发送请求，表现层的Servlet接收请求并调用业务逻辑层的方法进行业务逻辑处理，而业务逻辑层方法调用数据访问层方法进行数据的操作，依次返回到serlvet，然后servlet将数据交由 JSP 进行展示。\n\n3. MVC 和 三层架构\n如上图上半部分是 MVC 模式，上图下半部分是三层架构。 MVC 模式 中的 C（控制器）和 V（视图）就是 三层架构 中的表现层，而 MVC 模式 中的 M（模型）就是 三层架构 中的 业务逻辑层 和 数据访问层。\n可以将 MVC 模式 理解成是一个大的概念，而 三层架构 是对 MVC 模式 实现架构的思想。 那么我们以后按照要求将不同层的代码写在不同的包下，每一层里功能职责做到单一，将来如果将表现层的技术换掉，而业务逻辑层和数据访问层的代码不需要发生变化。\n6.8 案例需求：完成品牌数据的增删改查操作\n1. 环境准备","tags":["学习笔记"]},{"title":"Maven笔记","url":"/2022/06/29/Maven%E7%AC%94%E8%AE%B0/","content":"Maven1.1基本介绍Apache Maven 是一个项目管理和构建工具，它基于项目对象模型(POM)的概念，通过一小段描述信息来管理项目的构建、报告和文档\n\nMaven是专门用于管理和构建Java项目的工具，它的主要功能有：\n\n提供了一套标准化的项目结构\n\n提供了一套标准化的构建流程（编译，测试，打包，发布……）\n\n提供了一套依赖管理机制\n\n官网：http://maven.apache.org/\n\n\n\n标准化的构建流程：\n\n\n\n\n依赖管理：\n\n依赖管理其实就是管理你项目所依赖的第三方资源 (jar包、插件…)\n\n\n\n\n\n1.1.1 Maven模型\n项目对象模型 (Project Object Model)\n依赖管理模型(Dependency)\n插件(Plugin)\n\n\n一个普通的Maven项目\n\n1.1.2仓库仓库分类：\n\n本地仓库：自己计算机上的一个目录\n\n中央仓库：由Maven团队维护的全球唯一的仓库\n\n地址： https://repo1.maven.org/maven2/\n\n\n远程仓库(私服)：一般由公司团队搭建的私有仓库(阿里云等镜像站)\n\n\n当项目中使用坐标引入对应依赖jar包后，首先会查找本地仓库中是否有对应的jar包：\n\n如果有，则在项目直接引用;\n如果没有，则去中央仓库中下载对应的jar包到本地仓库。\n\n\n2.Maven安装配置\n官网下载绿色安装包：https://maven.apache.org/download.cgi?Preferred=ftp://ftp.osuosl.org/pub/apache/\n\n解压下载好的 apache-maven-3.8.6-bin.zip\n\n\n\nbin目录 ： 存放的是可执行命令。mvn 命令重点关注。\nconf目录 ：存放Maven的配置文件。settings.xml 配置文件后期需要修改。\nlib目录 ：存放Maven依赖的jar包。Maven也是使用java开发的，所以它也依赖其他的jar包。\n\n\n配置环境变量 MAVEN_HOME 为安装路径的bin目录\n此电脑 右键  –&gt;  高级系统设置  –&gt;  高级  –&gt;  环境变量\n在系统变量处新建一个变量 MAVEN_HOME变量值是maven解压的地方\n在 Path 中进行配置：%MAVEN_HOME%\\bin\n打开CMD终端，输入mvn -version\n\n\n配置本地仓库\n修改 conf&#x2F;settings.xml 中的  为一个指定目录作为本地仓库，用来存储jar包。\n&lt;!-- 指定仓库目录 --&gt;&lt;localRepository&gt;$&#123;user.home&#125;/.m2/repository&lt;/localRepository&gt;\n\n配置阿里云私服\n中央仓库在国外，所以下载jar包速度可能比较慢，而阿里公司提供了一个远程仓库，里面基本也都有开源项目的jar包。\n修改 conf&#x2F;settings.xml 中的 标签，为其添加如下子标签：\n&lt;mirror&gt;      &lt;id&gt;alimaven&lt;/id&gt;      &lt;name&gt;aliyun maven&lt;/name&gt;      &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;          &lt;/mirror&gt;\n\n我的完整配置\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!--Licensed to the Apache Software Foundation (ASF) under oneor more contributor license agreements.  See the NOTICE filedistributed with this work for additional informationregarding copyright ownership.  The ASF licenses this fileto you under the Apache License, Version 2.0 (the&quot;License&quot;); you may not use this file except in compliancewith the License.  You may obtain a copy of the License at    http://www.apache.org/licenses/LICENSE-2.0Unless required by applicable law or agreed to in writing,software distributed under the License is distributed on an&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANYKIND, either express or implied.  See the License for thespecific language governing permissions and limitationsunder the License.--&gt;&lt;!-- | This is the configuration file for Maven. It can be specified at two levels: | |  1. User Level. This settings.xml file provides configuration for a single user, |                 and is normally provided in $&#123;user.home&#125;/.m2/settings.xml. | |                 NOTE: This location can be overridden with the CLI option: | |                 -s /path/to/user/settings.xml | |  2. Global Level. This settings.xml file provides configuration for all Maven |                 users on a machine (assuming they&#x27;re all using the same Maven |                 installation). It&#x27;s normally provided in |                 $&#123;maven.conf&#125;/settings.xml. | |                 NOTE: This location can be overridden with the CLI option: | |                 -gs /path/to/global/settings.xml | | The sections in this sample file are intended to give you a running start at | getting the most out of your Maven installation. Where appropriate, the default | values (values used when the setting is not specified) are provided. | |--&gt;&lt;settings xmlns=&quot;http://maven.apache.org/SETTINGS/1.2.0&quot;          xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;          xsi:schemaLocation=&quot;http://maven.apache.org/SETTINGS/1.2.0 https://maven.apache.org/xsd/settings-1.2.0.xsd&quot;&gt;  &lt;!-- localRepository   | The path to the local repository maven will use to store artifacts.   |   | Default: $&#123;user.home&#125;/.m2/repository  &lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;  --&gt;  &lt;!-- 本地仓库地址 --&gt;  &lt;localRepository&gt;$&#123;user.home&#125;/.m2/repository&lt;/localRepository&gt;  &lt;!-- interactiveMode   | This will determine whether maven prompts you when it needs input. If set to false,   | maven will use a sensible default value, perhaps based on some other setting, for   | the parameter in question.   |   | Default: true  &lt;interactiveMode&gt;true&lt;/interactiveMode&gt;  --&gt;  &lt;!-- offline   | Determines whether maven should attempt to connect to the network when executing a build.   | This will have an effect on artifact downloads, artifact deployment, and others.   |   | Default: false  &lt;offline&gt;false&lt;/offline&gt;  --&gt;  &lt;!-- pluginGroups   | This is a list of additional group identifiers that will be searched when resolving plugins by their prefix, i.e.   | when invoking a command line like &quot;mvn prefix:goal&quot;. Maven will automatically add the group identifiers   | &quot;org.apache.maven.plugins&quot; and &quot;org.codehaus.mojo&quot; if these are not already contained in the list.   |--&gt;  &lt;pluginGroups&gt;    &lt;!-- pluginGroup     | Specifies a further group identifier to use for plugin lookup.    &lt;pluginGroup&gt;com.your.plugins&lt;/pluginGroup&gt;    --&gt;  &lt;/pluginGroups&gt;  &lt;!-- proxies   | This is a list of proxies which can be used on this machine to connect to the network.   | Unless otherwise specified (by system property or command-line switch), the first proxy   | specification in this list marked as active will be used.   |--&gt;  &lt;proxies&gt;    &lt;!-- proxy     | Specification for one proxy, to be used in connecting to the network.     |    &lt;proxy&gt;      &lt;id&gt;optional&lt;/id&gt;      &lt;active&gt;true&lt;/active&gt;      &lt;protocol&gt;http&lt;/protocol&gt;      &lt;username&gt;proxyuser&lt;/username&gt;      &lt;password&gt;proxypass&lt;/password&gt;      &lt;host&gt;proxy.host.net&lt;/host&gt;      &lt;port&gt;80&lt;/port&gt;      &lt;nonProxyHosts&gt;local.net|some.host.com&lt;/nonProxyHosts&gt;    &lt;/proxy&gt;    --&gt;  &lt;/proxies&gt;  &lt;!-- servers   | This is a list of authentication profiles, keyed by the server-id used within the system.   | Authentication profiles can be used whenever maven must make a connection to a remote server.   |--&gt;  &lt;servers&gt;    &lt;!-- server     | Specifies the authentication information to use when connecting to a particular server, identified by     | a unique name within the system (referred to by the &#x27;id&#x27; attribute below).     |     | NOTE: You should either specify username/password OR privateKey/passphrase, since these pairings are     |       used together.     |    &lt;server&gt;      &lt;id&gt;deploymentRepo&lt;/id&gt;      &lt;username&gt;repouser&lt;/username&gt;      &lt;password&gt;repopwd&lt;/password&gt;    &lt;/server&gt;    --&gt;    &lt;!-- Another sample, using keys to authenticate.    &lt;server&gt;      &lt;id&gt;siteServer&lt;/id&gt;      &lt;privateKey&gt;/path/to/private/key&lt;/privateKey&gt;      &lt;passphrase&gt;optional; leave empty if not used.&lt;/passphrase&gt;    &lt;/server&gt;    --&gt;  &lt;/servers&gt;  &lt;!-- mirrors   | This is a list of mirrors to be used in downloading artifacts from remote repositories.   |   | It works like this: a POM may declare a repository to use in resolving certain artifacts.   | However, this repository may have problems with heavy traffic at times, so people have mirrored   | it to several places.   |   | That repository definition will have a unique id, so we can create a mirror reference for that   | repository, to be used as an alternate download site. The mirror site will be the preferred   | server for that repository.   |--&gt;  &lt;mirrors&gt;    &lt;!-- mirror     | Specifies a repository mirror site to use instead of a given repository. The repository that     | this mirror serves has an ID that matches the mirrorOf element of this mirror. IDs are used     | for inheritance and direct lookup purposes, and must be unique across the set of mirrors.     |    &lt;mirror&gt;      &lt;id&gt;mirrorId&lt;/id&gt;      &lt;mirrorOf&gt;repositoryId&lt;/mirrorOf&gt;      &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt;      &lt;url&gt;http://my.repository.com/repo/path&lt;/url&gt;    &lt;/mirror&gt;     --&gt;&lt;!--    &lt;mirror&gt;      &lt;id&gt;maven-default-http-blocker&lt;/id&gt;      &lt;mirrorOf&gt;external:http:*&lt;/mirrorOf&gt;      &lt;name&gt;Pseudo repository to mirror external repositories initially using HTTP.&lt;/name&gt;      &lt;url&gt;http://0.0.0.0/&lt;/url&gt;      &lt;blocked&gt;true&lt;/blocked&gt;    &lt;/mirror&gt;--&gt;    &lt;mirror&gt;      &lt;id&gt;aliyunmaven&lt;/id&gt;      &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;      &lt;name&gt;aliyun maven&lt;/name&gt;      &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;    &lt;/mirror&gt;  &lt;/mirrors&gt;  &lt;!-- profiles   | This is a list of profiles which can be activated in a variety of ways, and which can modify   | the build process. Profiles provided in the settings.xml are intended to provide local machine-   | specific paths and repository locations which allow the build to work in the local environment.   |   | For example, if you have an integration testing plugin - like cactus - that needs to know where   | your Tomcat instance is installed, you can provide a variable here such that the variable is   | dereferenced during the build process to configure the cactus plugin.   |   | As noted above, profiles can be activated in a variety of ways. One way - the activeProfiles   | section of this document (settings.xml) - will be discussed later. Another way essentially   | relies on the detection of a system property, either matching a particular value for the property,   | or merely testing its existence. Profiles can also be activated by JDK version prefix, where a   | value of &#x27;1.4&#x27; might activate a profile when the build is executed on a JDK version of &#x27;1.4.2_07&#x27;.   | Finally, the list of active profiles can be specified directly from the command line.   |   | NOTE: For profiles defined in the settings.xml, you are restricted to specifying only artifact   |       repositories, plugin repositories, and free-form properties to be used as configuration   |       variables for plugins in the POM.   |   |--&gt;  &lt;profiles&gt;    &lt;!-- profile     | Specifies a set of introductions to the build process, to be activated using one or more of the     | mechanisms described above. For inheritance purposes, and to activate profiles via &lt;activatedProfiles/&gt;     | or the command line, profiles have to have an ID that is unique.     |     | An encouraged best practice for profile identification is to use a consistent naming convention     | for profiles, such as &#x27;env-dev&#x27;, &#x27;env-test&#x27;, &#x27;env-production&#x27;, &#x27;user-jdcasey&#x27;, &#x27;user-brett&#x27;, etc.     | This will make it more intuitive to understand what the set of introduced profiles is attempting     | to accomplish, particularly when you only have a list of profile id&#x27;s for debug.     |     | This profile example uses the JDK version to trigger activation, and provides a JDK-specific repo.    &lt;profile&gt;      &lt;id&gt;jdk-1.4&lt;/id&gt;      &lt;activation&gt;        &lt;jdk&gt;1.4&lt;/jdk&gt;      &lt;/activation&gt;      &lt;repositories&gt;        &lt;repository&gt;          &lt;id&gt;jdk14&lt;/id&gt;          &lt;name&gt;Repository for JDK 1.4 builds&lt;/name&gt;          &lt;url&gt;http://www.myhost.com/maven/jdk14&lt;/url&gt;          &lt;layout&gt;default&lt;/layout&gt;          &lt;snapshotPolicy&gt;always&lt;/snapshotPolicy&gt;        &lt;/repository&gt;      &lt;/repositories&gt;    &lt;/profile&gt;    --&gt;    &lt;!--     | Here is another profile, activated by the system property &#x27;target-env&#x27; with a value of &#x27;dev&#x27;,     | which provides a specific path to the Tomcat instance. To use this, your plugin configuration     | might hypothetically look like:     |     | ...     | &lt;plugin&gt;     |   &lt;groupId&gt;org.myco.myplugins&lt;/groupId&gt;     |   &lt;artifactId&gt;myplugin&lt;/artifactId&gt;     |     |   &lt;configuration&gt;     |     &lt;tomcatLocation&gt;$&#123;tomcatPath&#125;&lt;/tomcatLocation&gt;     |   &lt;/configuration&gt;     | &lt;/plugin&gt;     | ...     |     | NOTE: If you just wanted to inject this configuration whenever someone set &#x27;target-env&#x27; to     |       anything, you could just leave off the &lt;value/&gt; inside the activation-property.     |    &lt;profile&gt;      &lt;id&gt;env-dev&lt;/id&gt;      &lt;activation&gt;        &lt;property&gt;          &lt;name&gt;target-env&lt;/name&gt;          &lt;value&gt;dev&lt;/value&gt;        &lt;/property&gt;      &lt;/activation&gt;      &lt;properties&gt;        &lt;tomcatPath&gt;/path/to/tomcat/instance&lt;/tomcatPath&gt;      &lt;/properties&gt;    &lt;/profile&gt;    --&gt;      &lt;id&gt;jdk-1.8&lt;/id&gt;      &lt;activation&gt;          &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;          &lt;jdk&gt;1.8&lt;/jdk&gt;      &lt;/activation&gt;    &lt;properties&gt;        &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;        &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;        &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt;    &lt;/properties&gt;  &lt;/profiles&gt;  &lt;!-- activeProfiles   | List of profiles that are active for all builds.   |  &lt;activeProfiles&gt;    &lt;activeProfile&gt;alwaysActiveProfile&lt;/activeProfile&gt;    &lt;activeProfile&gt;anotherAlwaysActiveProfile&lt;/activeProfile&gt;  &lt;/activeProfiles&gt;  --&gt;&lt;/settings&gt;\n\n3.Maven基本使用1.3.1  Maven 常用命令\ncompile ：编译\nclean：清理\ntest：测试\npackage：打包\ninstall：安装\n\n1.3.2 Maven的生命周期Maven 构建项目生命周期描述的是一次构建过程经历经历了多少个事件\nMaven 对项目构建的生命周期划分为3套：\n\nclean ：清理工作。\ndefault ：核心工作，例如编译，测试，打包，安装等。\nsite ： 产生报告，发布站点等。这套声明周期一般不会使用。\n\n同一套生命周期内，执行后边的命令，前面的所有命令会自动执行。例如默认（default）生命周期如下：\n\n当我们执行 install（安装）命令时，它会先执行 compile命令，再执行 test  命令，再执行 package 命令，最后执行 install 命令。\n当我们执行 package （打包）命令时，它会先执行 compile 命令，再执行 test 命令，最后执行 package 命令。\n默认的生命周期也有对应的很多命令，其他的一般都不会使用，我们只关注常用的：\n\n1.3.3 IDEA使用Maven以后开发中我们肯定会在高级开发工具中使用Maven管理项目，而我们常用的高级开发工具是IDEA，所以接下来我们会讲解Maven在IDEA中的使用。\nIDEA配置Maven环境我们需要先在IDEA中配置Maven环境：\n\n选择 IDEA中 File –&gt; Settings\n\n搜索 maven \n\n设置 IDEA 使用本地安装的 Maven，并修改配置文件路径\n\n\n\n4 Maven 坐标详解什么是坐标？\n\nMaven 中的坐标是&#x3D;&#x3D;资源的唯一标识&#x3D;&#x3D;\n使用坐标来定义项目或引入项目中需要的依赖\n\nMaven 坐标主要组成\n\ngroupId：定义当前Maven项目隶属组织名称（通常是域名反写，例如：com.itheima）\n\nartifactId：定义当前Maven项目名称（通常是模块名称，例如 order-service、goods-service）\n\nversion：定义当前项目版本号\n\n\n上面所说的资源可以是插件、依赖、当前项目。\n\n我们的项目如果被其他的项目依赖时，也是需要坐标来引入的。\n\n\n5. 依赖管理5.1使用坐标引入jar包的步骤：\n在项目的 pom.xml 中编写  标签\n\n在  标签中 使用  引入坐标\n\n定义坐标的 groupId，artifactId，version\n\n\n点击刷新按钮，使坐标生效\n\n\n具体的坐标我们可以到如下网站进行搜索\n\nhttps://mvnrepository.com/\n\n\n快捷方式导入jar包的坐标：\n\n在 pom.xml 中 按 alt + insert，选择 Dependency\n在弹出的面板中搜索对应坐标，然后双击选中对应坐标\n点击刷新按钮，使坐标生效\n\n5.2 依赖范围通过设置坐标的依赖范围(scope)，可以设置 对应jar包的作用范围：编译环境、测试环境、运行环境。\n如下图所示给 junit 依赖通过 scope 标签指定依赖的作用范围。 那么这个依赖就只能作用在测试环境，其他环境下不能使用\n\nscope的依赖范围\n\n\n\n依赖范围\n编译classpath\n测试classpath\n运行classpath\n例子\n\n\n\ncompile\nY\nY\nY\nlogback\n\n\ntest\nN\nY\nN\nJunit\n\n\nprovided\nY\nY\nN\nservlet-api\n\n\nruntime\nN\nY\nY\njdbc驱动\n\n\nsystem\nY\nY\nN\n存储在本地的jar包\n\n\n\ncompile ：作用于编译环境、测试环境、运行环境。\ntest ： 作用于测试环境。典型的就是Junit坐标，以后使用Junit时，都会将scope指定为该值\nprovided ：作用于编译环境、测试环境。我们后面会学习 servlet-api ，在使用它时，必须将 scope 设置为该值，不然运行时就会报错\nruntime  ： 作用于测试环境、运行环境。jdbc驱动一般将 scope 设置为该值，当然不设置也没有任何问题 \n如果引入坐标不指定 scope 标签时，默认就是 compile  值。以后大部分jar包都是使用默认值。\n\n","tags":["学习笔记"]},{"title":"MySQL基础笔记","url":"/2022/06/21/MySQL%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/","content":"mysql基础知识安装及配置环境官网下载要使用的版本，按照安装程序来即可\n配置环境变量和java类似\nnavicat和sqlyog一直下一步即可\n数据库的基本使用登录：mysql -u root -p -h地址 -P端口号\n查看数据库：show databases;\n删除数据库：drop database if exists db_name(谨慎使用)\n备份数据库：mysqldump -u 用户名 -p -B 数据库1 数据库2 数据库N &gt; 文件名.sql(cmd或终端使用)\n恢复数据库：socrce 文件名.sql(mysql命令行使用)\n常用数据类型数值类型\nbit(m)\ntinyint(unsigend)\nsmallint(unsigend)\nmediumint(unsigend)\nint(unsigend)\nbigint(unsigend)\nfloat(unsigend)\ndouble(unsigend)\ndecimal(unsigend)\n\n字符串，二进制\nchar(size)\nvarchar(size)\nblob\ntext\n\n日期类型\ndate \ndatetime\ntimestamp\n\n表的基本使用创建表：create table tb_name();修改表\n添加列：alter table tb_name add();\n修改列：alter table tb_name modify()\n删除列：drop table tb_name drop()   desc可以查看表的结构\n\n数据库的crud添加语句：insert\ninsert into tb_name values()\n\n修改语句：update\nupdate tb_name set up_val [where]\n\n删除语句：delete\ndelete from tb_name [where]\n\n查询语句：select\nselect *{col1,col2} from tb_name[where]\n\nselect：查询哪些数据\n\ncol：查询哪些列\n\n*：表示查询所有列\n\nfrom：指定查询哪张表\n\ndistinct：可选项，查询时去重\n\norder by：以哪一列进行排序\n\nasc：升序(默认)\ndesc：降序\n\n\n\n\n增强查询\n\nlike操作符\n\n%: 表示0到多个字符\n_: 表示单个字符\n\n\n分页查询\n\nselect …limit start,rows 每页显示的记录数 * （第几页-1）,每页显示的记录数\n\n\n多表查询\n\n多表查询是指基于两个和两个以上的表查询\n\n多表查询的条件不能少于 表的个数-1, 否则会出现笛卡尔集\n\n自连接\n\n把同一张表当做两张表使用\n需要给表取别名 表名 表别名\n列名不明确，可以指定列的别名 列名 as\n\n\n\n\n子查询\n\n子查询是指嵌入在其它 sql 语句中的 select 语句,也叫嵌套查询\n\nselect * from emp where deptno &#x3D; (select deptno from emp where ename &#x3D; ‘SMITH’);\n\n\n单行子查询\n\n单行子查询是指只返回一行数据的子查询语句\n\n\n多行子查询\n\n多行子查询指返回多行数据的子查询 使用关键字 in\n\nselect ename, job, sal, deptno from empwhere job in (SELECT DISTINCT jobFROM emp WHERE deptno &#x3D; 10) and deptno &lt;&gt; 10\n\n\n\n\n子查询当作临时表使用\n\n\n\n合并查询\n\nunion：该操作符用于取得两个结果集的并集当使用该操作符时，不会取消重复行\n\nSELECT ename,sal,job FROM emp WHERE sal&gt;2500 – 5UNIONSELECT ename,sal,job FROM emp WHERE job&#x3D;’MANAGER\n\n\nunion all：该操作赋与union all相似，但是会自动去掉结果集中重复行\n\nSELECT ename,sal,job FROM emp WHERE sal&gt;2500 – 5UNION ALLSELECT ename,sal,job FROM emp WHERE job&#x3D;’MANAGER’ – 3\n\n\n\n\n\n\n表的复制\n\n自我复制数据(蠕虫复制)\n\n先把 表的记录复制到 my_tab01\n\n自我复制\n\nINSERT INTO my_tab01SELECT * FROM my_tab01;SELECT COUNT(*) FROM my_tab01;\n\n\n\n\n\n\n表外连接\n\n左外连接：如果左侧的表完全显示我们就说是左外连接\n\nselet… from 表1 left join 表2 on 条件\n\n\n右外连接：如果右侧的表完全显示我们就说是左外连接\n\nselet… from 表1 right join 表2 on 条件\n\n\n\n\n\n函数的基本使用合计&#x2F;统计函数\ncount：返回行的总数\n\nselect count(*) from tb_name where\n\n\nsum：返回满足where条件的和 一般用在数值上\n\nselect sum(列名) from tb_name where\n\n\navg：返回满足where条件的平均值 \n\nselect avg(列名)  from table where\n\n\nmax&#x2F;min：返回满足where条件的最大值&#x2F;最小值\n\nselect max(列名) from tb_name where\n\n\ngroup by：对列进行分组\n\nselect col1,col2 from tb_name group by col\n\n\nhaving：分组后进行过滤\n\nselect col1,col2 from tb_name group by col having ….\n\n\n\n字符串相关函数\ncharset(str)：返回字符串集\nconcat(string,string2…)：连接字符串\ninstr(string,substring)：返回substring在string出现的位置，没用返回0\nucase(string)：转为大写\nlcase(string)：转为小写\nleft(string2,lenth)：从string2中的左边起lenth个字符\nlenth(string)：string的长度【按照字节】\nreplace(str,search_str,replace_str)：替换字符串\nstrcmp(string1,string2)：比较两字符串的大小\nsubstring(str,position,[lenth])：从str的position开始【从1开始计算】,去lenth个字符\nltrim(string),rtrim(String)：去除前端或后端空格\n\n数学函数\nabs(num)：绝对值\nbin(num)：十进制转二进制\nhex(num)：转为16进制\nceiling(num)：向上取整\nfloor(num)：向下取整\nleast(num,num2)：求最小值\nmod(num)：求余\nrand(seed)：取范围为0 &lt;&#x3D; num &lt;&#x3D; 1.0\nround(num)：四舍五入\n\n日期函数\ncurrent_date()：当前日期\ncurrent_time()：当前时间\ncurrent_timestamp()：当前时间戳\ndate(datetime)：返回datetime的日期部分\ndate_add(date,interval value type)：在date基础上加上日期或时间\ndate_sub(date,interval value type)：在date基础上减去日期或时间\ndatediff(date1,date2)：两个日期差（结果为天）\ntimediff(date1,date2)：两个时间差（结果是时分秒）\nnow()：当前时间\n\n加密和系统函数\nuser()：查询用户\ndatebase()：数据库名称\npassword()：密码加密(8.0后已失效)\nmd5()：md5加密(8.0后使用)\n\n流程控制函数\nif(exper1,exper2,exper3)：如果exp1为TRUE，则返回exp2,否则返回exp3\nifnull(exp1,exp2)：如果exp1不为null,则返回exp1，否则返回exp2\nselect case when exp1 then exp2 when exp3 then exp4 else exp5 end：如果exp1为true，则返回exp2\n\n约束约束用于确保数据库的数据满足特定的商业规则\n\nnot null \n\n不为空，如果在列上定义了not null,那么当插入数据时，必须为列提供数据\n\n\nunique\n\n唯一的，当定义了唯一约束后，该列值是不能重复的。\n如果没有指定not null,则unique字段可以有多个nul\n一张表可以有多个unique字段\n\n\nprimary key 主键\n\nprimary key不能重复而且不能为null。\n\n一张表最多只能有一个主键，但可以是复合主建\n\nprimakry key(列1，列2)\n\n\n主键的指定方式\n\n字段名 primakry key\n在表定义最后写：primary key(列名)\n\n\ndesc 表名可以查看主键\n\n每张表往往会设计一个主键\n\n\n\nforeign key\n\n用于定义主表和从表之间的关系\nFOREIGN KEY(本表字段名)REFERENCES生表名（主键名或unique:字段名）\n外键指问的表的字段，要球是primary key可或者是unique\n表的类型是innodb,这样的表才支持外键\n外键字段的类型要和主键字段的类型一致（长度可以不同）\n外键字段的值，必须在主键字段中出现过，或者为null[前提是外键字段允许为null]\n一旦建立主外键的关系，数据不能随意删除了\n\n\ncheak\n\n5.7只是语法校验，8.0后才生效\n\n\nauto_increment 自增长\n\nprimary key auto_increment\n一般来说自增长是和primary key配合使用的\n自增长也可以单独使用[但是需要配合一个[unique]\n自增长修饰的字段为整数型的（虽然小数也可以但是非常非常少这样使用)\n自增长默认从1开始，你也可以通过如下命令修改atertable表名auto increment&#x3D;新的开始值；\n如果你添加数据时，给自增长字段（列）指定的有值，则以指定的值为准，如果指定了自增长，一般来说，就按照自增长的规则来添加数据.\n\n\n\n索引原理\n数据量很大时，查询是二叉树\n\n代价\n\n更多的磁盘占用\n对DML语句的效率影响\n\n\n\n索引类型\n主键类型，主动自动的为主索引(类型Primary key)\n\n唯一索引(unique)\n\n普通索引(index)\n\n全文索引(fulltext)\n\n一般开发，不使用ysql自带的全文索引，而是使用：全文搜索Solr ElasticSearch (ES)\n\n\n\n索引的使用\n添加\n\n添加索引\n\ncreate unique index index_name on tb_name\n\n\n添加主键索引\n\nalter table tb_name add primary key\n\n\n\n\n删除索引\n\n删除索引\n\ndrop index index_name on tb_name\n\n\n删除主键索引\n\nalter table tb_name drop primary key\n\n\n\n\n查询索引\n\nshow index(es) from tb_name\nshow key from tb_name\ndesc tb_name\n\n\n\n那些列适合索引\n较频繁的作为查询条件字段应该创建索引\n\nselect from emp where empno 1\n\n\n唯一性太差的字段不适合单独创建索引，即使频繁作为查询条件\n\nselect from emp where sex &#x3D;\n\n\n更新非常频繁的字段不适合创建索引\n\nselect from emp where logincount 1\n\n\n不会出现在VHERE子句中字段不该创建索\n\n\n事物什么是事物\n事务用于保证数据的一致性，它由一组相关的dml语句组成，该组的dml语句要么全部成功，要么全部失败。\n\n基本操作\n开始一个事物：start transaction\n保存点：savepoint\nrollback to 保存点名–&gt;回退事物\nrollback 回退全部事物\ncommit 提交事物，提交后无法回退\n\n小细节\n如果不开始事务，默认情况下，dml 操作是自动提交的，不能回滚\n如果开始一个事务，你没有创建保存点. 你可以执行 rollback,默认回退到事物开始的状态\n你也可以在这个事务中(还没有提交时), 创建多个保存点\n你可以在事务没有提交前，选择回退到哪个保存点\nInnoDB 存储引擎支持事务 , MyISAM\n\n事物隔离级别\n什么是事物隔离\n\n多个连接开启各自事务操作数据库中数据时，数据库系统要负责隔离操作，以保证各个连接在获取数据时的准确性。\n\n如果不考虑隔离性，可能会引发下面问题\n\n脏读\n不可重复读\n幻读\n\n\n\n\n四种隔离级别\n\n读未提交(read uncommitted)\n读已提交(read committed)\n可重复读(repeatable read)\n可串行化(serializable)\n\n\n设置隔离级别\n\n查看当前会话隔离级别\n\nselect @@transaction_isolation;\n\n\n设置会话隔离级别为可重复读\n\nset session transaction isolation level repeatable read;\n\n\n设置会话隔离级别为读未提交\n\nset session transaction isolation level read uncommitted;\n\n\n设置会话隔离级别为读已提交\n\nset session transaction isolation level read committed;\n\n\n\n\n事物ACID\n\n原子性\n\n原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。\n\n\n一致性\n\n事务必须使数据库从一个一致性状态变换到另外一个一致性状态\n\n\n隔离性\n\n事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离\n\n\n持久性\n\n持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的接下来即使数据库发生故障也不应该对其有任何影响\n\n\n\n\n\nmysql 引擎六种类型\n\nCSV\n\nMemory\n\n数据存储在内存中[关闭了 Mysql 服务，数据丢失, 但是表结构还在]\n执行速度很快(没有 IO 读写) \n默认支持索引(hash 表\n\n\nARCHIVE\n\nMRG_MYISAM\n\nMYISAM\n\n添加速度快\n不支持外键和事物\n支持表级锁\n\n\nInnodbd\n\n支持事物\n支持外键\n支持行级锁\n\n\n\n如何选择\n如果你的应用不需要事务，处理的只是基本的CRUD操作，那么MyISAM是不二选择，速度快\n如果需要支持事务，选择InnoDB。\nMemory存储引擎就是将数据存储在内存中，由于没有磁盘I.&#x2F;O的等待，速度极快。但由于是内存存储引擎，所做的任何修改在服务器重启后都将消失。（经典用法用户的在线状态0）\n\n视图基本概念\n视图是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含列，其数据来自对应的真实表（基表）\n视图是根据基表（可以是多个基表）来创建的视图是虚拟的表\n视图也有列，数据来自基表\n通过视图可以修改基表的数据\n基表的改变，也会影响到视图的数据\n\n基本使用\n创建视图\n\ncreate view 视图名  as select语句\n\n\n更新成新视图\n\nalter view 视图名 as select语句\n\n\n查看视图\n\nshow create view\n\n\n删除视图\n\ndrop view 视图1,视图2\n\n\n\n","tags":["学习笔记"]},{"title":"MyBatis笔记","url":"/2022/06/29/MyBatis%E7%AC%94%E8%AE%B0/","content":"MyBatis1.MyBatis介绍1.1 什么是MyBatis\nMyBatis 是一款优秀的持久层框架，用于简化 JDBC 开发\nMyBatis 本是 Apache 的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github\n官网：https://mybatis.org/mybatis-3/zh/index.html\n\n1.2 Mybatis快速入门用Mybatis查询表里的所有数据\n\n创建表\ncreate database mybatis;use mybatis;drop table if exists tb_user;create table tb_user(\tid int primary key auto_increment,\tusername varchar(20),\tpassword varchar(20),\tgender char(1),\taddr varchar(30));INSERT INTO tb_user VALUES (1, &#x27;张三&#x27;, &#x27;123&#x27;, &#x27;男&#x27;, &#x27;北京&#x27;);INSERT INTO tb_user VALUES (2, &#x27;李四&#x27;, &#x27;234&#x27;, &#x27;女&#x27;, &#x27;天津&#x27;);INSERT INTO tb_user VALUES (3, &#x27;王五&#x27;, &#x27;11&#x27;, &#x27;男&#x27;, &#x27;西安&#x27;);\n\n2.创建模块，导入相关依赖\n\nIDEA–&gt;新建–&gt;模块–模块名 构建系统选择Maven –&gt;创建\n\n导入相关依赖\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;org.example&lt;/groupId&gt;    &lt;artifactId&gt;Mybatis&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;properties&gt;        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;!-- mybatis --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;            &lt;version&gt;3.5.10&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- mysql --&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;8.0.29&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- junit --&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.13.2&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- slf4j --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;            &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;            &lt;version&gt;1.7.36&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- logback-classic --&gt;        &lt;dependency&gt;            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;            &lt;version&gt;1.2.11&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- 添加logback-core依赖 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;            &lt;artifactId&gt;logback-core&lt;/artifactId&gt;            &lt;version&gt;1.2.3&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;\n\n创建pojo类\npublic class User &#123;    private Integer id;    private String username;    private String password;    private String gender;    private String addr;    public Integer getId() &#123;        return id;    &#125;    public void setId(Integer id) &#123;        this.id = id;    &#125;    public String getUsername() &#123;        return username;    &#125;    public void setUsername(String username) &#123;        this.username = username;    &#125;    public String getPassword() &#123;        return password;    &#125;    public void setPassword(String password) &#123;        this.password = password;    &#125;    public String getGender() &#123;        return gender;    &#125;    public void setGender(String gender) &#123;        this.gender = gender;    &#125;    public String getAddr() &#123;        return addr;    &#125;    public void setAddr(String addr) &#123;        this.addr = addr;    &#125;    @Override    public String toString() &#123;        return &quot;User&#123;&quot; +                &quot;id=&quot; + id +                &quot;, username=&#x27;&quot; + username + &#x27;\\&#x27;&#x27; +                &quot;, password=&#x27;&quot; + password + &#x27;\\&#x27;&#x27; +                &quot;, gender=&#x27;&quot; + gender + &#x27;\\&#x27;&#x27; +                &quot;, addr=&#x27;&quot; + addr + &#x27;\\&#x27;&#x27; +                &#x27;&#125;&#x27;;    &#125;&#125;\n\n从 XML 中构建 SqlSessionFactory\n在src–&gt;main–&gt;resources 新建一个mybatis-config.xml\nmysq连接信息的对应位置输入mysql相关信息\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;environments default=&quot;development&quot;&gt;        &lt;environment id=&quot;development&quot;&gt;            &lt;!-- mysql连接信息 --&gt;            &lt;transactionManager type=&quot;JDBC&quot;/&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///mybatis?rewriteBatchedStatements=true&quot;/&gt;                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;                &lt;property name=&quot;password&quot; value=&quot;abcd1234&quot;/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;mappers&gt;        &lt;!-- sql映射文件 --&gt;        &lt;mapper resource=&quot;UserMapper.xml&quot;/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;\n\n在src–&gt;main–&gt;resources 新建一个sql映射文件,建议xxxMapper.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!-- namespace是空间名称\t resultType 返回的类型 \t id 本次查询的id--&gt;&lt;mapper namespace=&quot;test&quot;&gt;    &lt;select id=&quot;selectAll&quot; resultType=&quot;com.ithm.pojo.User&quot;&gt;        select * from tb_user;    &lt;/select&gt;&lt;/mapper&gt;\n\n在mybatis-config.xml里面的mapper resource&#x3D;”” 填入sql映射文件\n\n使用Mybatis \n新建一个Mybatis测试类\nimport com.ithm.pojo.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;import java.util.List;public class MybatisTest &#123;    public static void main(String[] args) throws IOException &#123;        //加载mybatis的核心配置文件 获取sqlsessionFactory        String resource = &quot;mybatis-config.xml&quot;;        InputStream inputStream = Resources.getResourceAsStream(resource);        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);        //获取sqlsession对象        SqlSession sqlSession = sqlSessionFactory.openSession();        //执行sql语句        //空间名称+查询id        List&lt;User&gt; users = sqlSession.selectList(&quot;test.selectAll&quot;);        System.out.println(users);        //释放资源        sqlSession.close();    &#125;&#125;\n\n查询结果\n\n\n\n\n\n2.Mapper代理开发2.1为什么要用它\n解决原生方式中的硬编码\n\n\n\n简化后期执行SQL\n\n2.2 使用 Mapper 代理方式完成入门案例\n定义与SQL映射文件同名的Mapper接口，并且将Mapper接口和SQL映射文件放置在同一目录下\n\n在src –&gt; main –&gt; java 新建一个mapper的包，包里新建SQL映射文件同名的Mapper接口\n在resources新建和上面同样的目录，将SQL映射文件拖进去\n\n\n设置SQL映射文件的namespace属性为Mapper接口全限定名在 Mapper 接口中定义方法，方法名就是SQL映射文件中sql语句的id，并保持参数类型和返回值类型一致\n\n将SQL映射文件的namespace属性为Mapper(com.ithm.mapper.UserMapper”)\n\n在UserMapper接口里面添加sql映射文件里namespace对应的方法，返回值要正确\npublic interface UserMapper &#123;    List&lt;User&gt; selectAll();&#125;\n\n修改mybatis-config.xml里的sql映射文件的路径\n\n此处可以使用mapper代理的方式，简化后期的代码\n\n&lt;mappers&gt;        &lt;!-- sql映射文件 --&gt;        &lt;!--mapper resource=&quot;com/ithm/mapper/UserMapper.xml&quot;/--&gt;        &lt;!-- mapper的代理方式 --&gt;        &lt;package name=&quot;com.ithm.mapper&quot;/&gt;    &lt;/mappers&gt;\n\n\n编码\n\n通过 SqlSession 的 getMapper方法获取 Mapper接口的代理对象\n调用对应方法完成sql的执行\n\npackage com.ithm.test;import com.ithm.mapper.UserMapper;import com.ithm.pojo.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;import java.util.List;//MybatisTest代理开发public class MybatisTest2 &#123;    public static void main(String[] args) throws IOException &#123;        //加载mybatis的核心配置文件 获取sqlsessionFactory        String resource = &quot;mybatis-config.xml&quot;;        InputStream inputStream = Resources.getResourceAsStream(resource);        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);        //获取sqlsession对象        SqlSession sqlSession = sqlSessionFactory.openSession();        //执行sql语句        //获取usermapper接口的代理对象        UserMapper mapper = sqlSession.getMapper(UserMapper.class);        List&lt;User&gt; users = mapper.selectAll();        System.out.println(users);        //释放资源        sqlSession.close();    &#125;&#125;\n\n3.Mybatis核心配置文件3.1MyBatis 核心配置文件的顶层结构\n3.2类型别名Mybatis-config.xml里可以加入别名来简化Mapper的resultType\n&lt;!-- 别名 --&gt;&lt;typeAliases&gt;    &lt;package name=&quot;com.ithm.pojo&quot;/&gt;&lt;/typeAliases&gt;\n\n&lt;mapper namespace=&quot;com.ithm.mapper.UserMapper&quot;&gt;    &lt;select id=&quot;selectAll&quot; resultType=&quot;user&quot;&gt;        select * from tb_user;    &lt;/select&gt;&lt;/mapper&gt;\n\n3.3更多信息可以查看官方文档\n4.配置文件完成增删改查产品原型\n4.1配置环境\n准备数据库\n-- 删除tb_brand表drop table if exists tb_brand;-- 创建tb_brand表create table tb_brand(    -- id 主键    id           int primary key auto_increment,    -- 品牌名称    brand_name   varchar(20),    -- 企业名称    company_name varchar(20),    -- 排序字段    ordered      int,    -- 描述信息    description  varchar(100),    -- 状态：0：禁用  1：启用    status       int);-- 添加数据insert into tb_brand (brand_name, company_name, ordered, description, status)values (&#x27;三只松鼠&#x27;, &#x27;三只松鼠股份有限公司&#x27;, 5, &#x27;好吃不上火&#x27;, 0),       (&#x27;华为&#x27;, &#x27;华为技术有限公司&#x27;, 100, &#x27;华为致力于把数字世界带入每个人、每个家庭、每个组织，构建万物互联的智能世界&#x27;, 1),       (&#x27;小米&#x27;, &#x27;小米科技有限公司&#x27;, 50, &#x27;are you ok&#x27;, 1);SELECT * FROM tb_brand;\n\n准备商品类\npackage com.itheima.pojo;/** * 品牌 * * alt + 鼠标左键：整列编辑 * * 在实体类中，基本数据类型建议使用其对应的包装类型 */public class Brand &#123;    // id 主键    private Integer id;    // 品牌名称    private String brandName;    // 企业名称    private String companyName;    // 排序字段    private Integer ordered;    // 描述信息    private String description;    // 状态：0：禁用  1：启用    private Integer status;    public Integer getId() &#123;        return id;    &#125;    public void setId(Integer id) &#123;        this.id = id;    &#125;    public String getBrandName() &#123;        return brandName;    &#125;    public void setBrandName(String brandName) &#123;        this.brandName = brandName;    &#125;    public String getCompanyName() &#123;        return companyName;    &#125;    public void setCompanyName(String companyName) &#123;        this.companyName = companyName;    &#125;    public Integer getOrdered() &#123;        return ordered;    &#125;    public void setOrdered(Integer ordered) &#123;        this.ordered = ordered;    &#125;    public String getDescription() &#123;        return description;    &#125;    public void setDescription(String description) &#123;        this.description = description;    &#125;    public Integer getStatus() &#123;        return status;    &#125;    public void setStatus(Integer status) &#123;        this.status = status;    &#125;    @Override    public String toString() &#123;        return &quot;Brand&#123;&quot; +                &quot;id=&quot; + id +                &quot;, brandName=&#x27;&quot; + brandName + &#x27;\\&#x27;&#x27; +                &quot;, companyName=&#x27;&quot; + companyName + &#x27;\\&#x27;&#x27; +                &quot;, ordered=&quot; + ordered +                &quot;, description=&#x27;&quot; + description + &#x27;\\&#x27;&#x27; +                &quot;, status=&quot; + status +                &#x27;&#125;&#x27;;    &#125;&#125;\n\n准备测试用例\n在maven项目里的test –&gt; java创建MyBatisTest.java\n\n安装Mybatis X的插件\n\n\n4.2完成查询操作4.2.1 查询所有数据\n编写接口方法： Mapper接口\n\n参数：无\n结果：List\n\n\n编写 SQL语句： SQL映射文件：\n\n执行方法，测试\n新建BrandMapper接口\npublic interface BrandMapper &#123;    List&lt;Brand&gt; selectAll();&#125;\n\n新建BrandMapper.xml,编写接口里对应的sql语句\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.ithm.mapper.BrandMapper&quot;&gt;    &lt;select id=&quot;selectAll&quot; resultMap=&quot;brandResultMap&quot;&gt;        select * from tb_brand;    &lt;/select&gt;&lt;/mapper&gt;\n\n开始测试\n@Testpublic void testSelectAll() throws IOException &#123;    //1.获取对应的sqlsessionFactory对象    String resource = &quot;mybatis-config.xml&quot;;    InputStream inputStream = Resources.getResourceAsStream(resource);    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);       //获取sqlsessionduix    SqlSession sqlSession = sqlSessionFactory.openSession();       //获取Mapper接口代理对象    BrandMapper mapper = sqlSession.getMapper(BrandMapper.class);       //执行方法    List&lt;Brand&gt; brands = mapper.selectAll();    System.out.println(brands);       //释放资源    sqlSession.close();&#125;\n\n问题\n数据库表的字符名和实体类的字段名不一样，查询结果显示有问题\n解决方法\n\n编写sql语句时给字段其别名，别名的实体类的一致(太复杂)\n\nresultMap\n&lt;resultMap id=&quot;brandResultMap&quot; type=&quot;brand&quot;&gt;    &lt;!--        id 完成主键的映射        result 完成一般的映射        column 表的列名        property 实体类属性    --&gt;    &lt;result column=&quot;brand_name&quot; property=&quot;brandName&quot;&gt;&lt;/result&gt;    &lt;result column=&quot;company_name&quot; property=&quot;companyName&quot;&gt;&lt;/result&gt;&lt;/resultMap&gt;     &lt;select id=&quot;selectAll&quot; resultMap=&quot;brandResultMap&quot;&gt;    select * from tb_brand;&lt;/select&gt;\n\n\n\n4.2.2查询详情\n编写接口方法： Mapper接口参数：id结果：Brand\n\n编写 SQL语句： SQL映射文件\n\n执行方法，测试\nMapper接口里新增查询方法\n/** * @Description 根据id查询 * @param id * @return */Brand selectById(int id);\n\nＭapper.xml加入对应的sql语句\n&lt;!--        Mybatis的参数占位符        #&#123;&#125; 会将传入的值替换为? 防止sql注入        $&#123;&#125; 直接拼接sql语句，有sql的注入的风险        如何选择？        参数传递使用#&#123;&#125;        表名或列名不固定用 &amp;&#123;&#125;        特殊字符的处理        select * from tb_brand where id &lt; #&#123;id&#125; 会和xml语法冲突        转义字符：&amp;li  select * from tb_brand where id &amp;lt; #&#123;id&#125;;        CDATA: select * from tb_brand where id &lt;![CDATA[&lt;]]&gt; #&#123;id&#125; 字符多的时候使用    --&gt;    &lt;select id=&quot;selectById&quot; resultMap=&quot;brandResultMap&quot;&gt;        select * from tb_brand where id = #&#123;id&#125;;    &lt;/select&gt;\n\n注意事项\n\n参数占位符：\n#{}：执行SQL时，会将#{}占位符替换为?,将来自动设置参数 \n${}：拼SQL。会存在SQL注入问题\n使用时机：\n参数传递，都使用#{}\n如果要对表名、列名进行动态设置，只能使用${}进行sql拼接。\n\n\n\n\nparameterType\n用于设置参数类型，该参数可以省略\n\n\nSQL 语句中特殊字符处理：\n转义字符\nCD　IDE会有提示\n\n\n\n\n\n4.2.3 条件查询4.2.3.1多条件查询\n编写接口方法： Mapper接口\n\n参数：所有查询条件\n结果：List\n\n\n编写 SQL语句： SQL映射文件\n\n执行方法，测试\nＭapper接口新建查询方法\n三种动态方式传参\n\n散装参数：需要使用@Param(“SQL中的参数名称”)使用麻烦\nList&lt;Brand&gt; selectCondition(@Param(&quot;status&quot;)int status,@Param(&quot;companyName&quot;)String companyName,                          //@Param(&quot;brandName&quot;)String brandName);\n\n实体类封装参数：只需要保证SQL中的参数名 和 实体类属性名对应上，即可设置成功\nList&lt;Brand&gt; selectCondition(Brand brand);\n\nmap集合：只需要保证SQL中的参数名 和 map集合的键的名称对应上，即可设置成功\nList&lt;Brand&gt; selectCondition(Map map);\n\nMapper.xml文件编写sql语句\n&lt;select id=&quot;selectCondition&quot; resultMap=&quot;brandResultMap&quot;&gt;    select * from tb_brand where status = #&#123;status&#125; and company_Name like #&#123;companyName&#125; and brand_Name like #&#123;brandName&#125;;&lt;/select&gt;\n\n测试方法\n\n使用散装参数\n@Test    public void testSelectCondition() throws IOException &#123;        //获取参数        int status = 1;        String companyName = &quot;小米&quot;;        String brandName = &quot;小米&quot;;        //处理参数        companyName = &quot;%&quot; + companyName + &quot;%&quot;;        brandName = &quot;%&quot; + brandName + &quot;%&quot;;        //1.获取对应的sqlsessionFactory对象        String resource = &quot;mybatis-config.xml&quot;;        InputStream inputStream = Resources.getResourceAsStream(resource);        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);        //获取sqlsessionduix        SqlSession sqlSession = sqlSessionFactory.openSession();        //获取Mapper接口代理对象        BrandMapper mapper = sqlSession.getMapper(BrandMapper.class);        //使用散装参数传参        List&lt;Brand&gt; brands = mapper.selectCondition(status, companyName, brandName);        System.out.println(brand);        //释放资源        sqlSession.close();    &#125;\n\n实体类封装参数\n@Testpublic void testSelectCondition() throws IOException &#123;    //获取参数    int status = 1;    String companyName = &quot;小米&quot;;    String brandName = &quot;小米&quot;;          //处理参数    companyName = &quot;%&quot; + companyName + &quot;%&quot;;    brandName = &quot;%&quot; + brandName + &quot;%&quot;;          //实体类封装参数    Brand brand = new Brand();    brand.setStatus(status);    brand.setCompanyName(companyName);    brand.setBrandName(brandName);          //1.获取对应的sqlsessionFactory对象    String resource = &quot;mybatis-config.xml&quot;;    InputStream inputStream = Resources.getResourceAsStream(resource);    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);          //获取sqlsessionduix    SqlSession sqlSession = sqlSessionFactory.openSession();          //获取Mapper接口代理对象    BrandMapper mapper = sqlSession.getMapper(BrandMapper.class);          //传入封装的对象    List&lt;Brand&gt; brands = mapper.selectCondition(brand);    System.out.println(brands);    //释放资源    sqlSession.close();&#125;\n\nmap集合的方式传入参数\n  @Test  public void testSelectCondition() throws IOException &#123;      //获取参数      int status = 1;      String companyName = &quot;小米&quot;;      String brandName = &quot;小米&quot;;            //处理参数      companyName = &quot;%&quot; + companyName + &quot;%&quot;;      brandName = &quot;%&quot; + brandName + &quot;%&quot;;      //创建参数放入到集合里面      Map map = new HashMap();      map.put(&quot;status&quot; ,status);      map.put(&quot;companyName&quot;, companyName);      map.put(&quot;brandName&quot;,brandName);      //1.获取对应的sqlsessionFactory对象      String resource = &quot;mybatis-config.xml&quot;;      InputStream inputStream = Resources.getResourceAsStream(resource);      SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);            //获取sqlsessionduix      SqlSession sqlSession = sqlSessionFactory.openSession();            //获取Mapper接口代理对象      BrandMapper mapper = sqlSession.getMapper(BrandMapper.class);            //执行方法3      List&lt;Brand&gt; brands = mapper.selectCondition(map);      System.out.println(brands);      //释放资源      sqlSession.close();  &#125;\n\n\n问题\n如果只传入一个参数则无法查询到数据\n@Testpublic void testSelectCondition() throws IOException &#123;    //获取参数    int status = 1;    String companyName = &quot;小米&quot;;    String brandName = &quot;小米&quot;;       //处理参数    companyName = &quot;%&quot; + companyName + &quot;%&quot;;    brandName = &quot;%&quot; + brandName + &quot;%&quot;;       //实体类封装参数    //此时只传入一个参数    Brand brand = new Brand();    brand.setBrandName(brandName);       //1.获取对应的sqlsessionFactory对象    String resource = &quot;mybatis-config.xml&quot;;    InputStream inputStream = Resources.getResourceAsStream(resource);    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);       //获取sqlsessionduix    SqlSession sqlSession = sqlSessionFactory.openSession();       //获取Mapper接口代理对象    BrandMapper mapper = sqlSession.getMapper(BrandMapper.class);       //传入封装的对象    List&lt;Brand&gt; brands = mapper.selectCondition(brand);    System.out.println(brands);    //查询到的结果为空    //释放资源    sqlSession.close();&#125;\n\n需要用到动态sql查询\n\n\n4.3.2 动态sql动态多条件查询SQL语句会随着用户的输入或外部条件的变化而变化，我们称为 动态SQL\n\nif：条件判断\ntest：逻辑表达式\n\n\nchoose (when, otherwise)\ntrim (where, set)\nforeach\n\n使用if语句解决上面的问题\n&lt;select id=&quot;selectCondition&quot; resultMap=&quot;brandResultMap&quot;&gt;        select * from tb_brand where                 &lt;if test=&quot;status != null&quot;&gt;                     and status = #&#123;status&#125;                 &lt;/if&gt;                 &lt;if test=&quot;companyName != null and companyName != &#x27;&#x27; &quot;&gt;                     and company_Name like #&#123;companyName&#125;                 &lt;/if&gt;                 &lt;if test=&quot;brandName != null and brandName != &#x27;&#x27; &quot;&gt;                     and brand_name like #&#123;brandName&#125;                 &lt;/if&gt;    &lt;/select&gt;\n\n但是会有新的问题\n如果第一条语句不成立，则会出现语法错误　and company_Name like #{companyName} ………\n解决方法：\n\n恒等式\n在where 后面写一条永远为Ｔrue的语句 \n&lt;select id=&quot;selectCondition&quot; resultMap=&quot;brandResultMap&quot;&gt;        select * from tb_brand where 1 = 1                 &lt;if test=&quot;status != null&quot;&gt;                     and status = #&#123;status&#125;                 &lt;/if&gt;                 &lt;if test=&quot;companyName != null and companyName != &#x27;&#x27; &quot;&gt;                     and company_Name like #&#123;companyName&#125;                 &lt;/if&gt;                 &lt;if test=&quot;brandName != null and brandName != &#x27;&#x27; &quot;&gt;                     and brand_name like #&#123;brandName&#125;                 &lt;/if&gt;    &lt;/select&gt;\n\nwhere标签替换关键字\n\n替换where关键字\n会动态的去掉第一个条件前的 and \n如果所有的参数没有值则不加where关键字\n\n&lt;select id=&quot;selectCondition&quot; resultMap=&quot;brandResultMap&quot;&gt;        select * from tb_brand        &lt;where&gt;            &lt;if test=&quot;status != null&quot;&gt;                and status = #&#123;status&#125;            &lt;/if&gt;            &lt;if test=&quot;companyName != null and companyName != &#x27;&#x27; &quot;&gt;                and company_Name like #&#123;companyName&#125;            &lt;/if&gt;            &lt;if test=&quot;brandName != null and brandName != &#x27;&#x27; &quot;&gt;                and brand_name like #&#123;brandName&#125;            &lt;/if&gt;        &lt;/where&gt;    &lt;/select&gt;\n\n动态单条件查询choose标签：相当于switch\nwhen标签：相当于case\notherwise：相当于default\nMapper接口添加方法\nList&lt;Brand&gt; selectByConditionSingle(Brand brand);\n\nMapper xml文件添加对应的sql语句\n&lt;select id=&quot;selectByConditionSingle&quot; resultMap=&quot;brandResultMap&quot;&gt;    select *    from tb_brand    &lt;where&gt;        &lt;choose&gt;&lt;!--相当于switch--&gt;            &lt;when test=&quot;status != null&quot;&gt;&lt;!--相当于case--&gt;                status = #&#123;status&#125;            &lt;/when&gt;            &lt;when test=&quot;companyName != null and companyName != &#x27;&#x27; &quot;&gt;&lt;!--相当于case--&gt;                company_name like #&#123;companyName&#125;            &lt;/when&gt;            &lt;when test=&quot;brandName != null and brandName != &#x27;&#x27;&quot;&gt;&lt;!--相当于case--&gt;                brand_name like #&#123;brandName&#125;            &lt;/when&gt;        &lt;/choose&gt;    &lt;/where&gt;&lt;/select&gt;\n\n4.3 完成添加操作Mapper接口添加方法\nvoid add(Brand brand);\n\nMapperXML文件添加sql语句\n&lt;insert id=&quot;add&quot;&gt;        insert into tb_brand (brand_name,company_name,ordered,description,status)        values (#&#123;brandName&#125;,#&#123;companyName&#125;,#&#123;ordered&#125;,#&#123;description&#125;,#&#123;status&#125;) ;    &lt;/insert&gt;\n\n测试方法\n@Test    public void add() throws IOException &#123;        //获取参数        int status = 1;        String companyName = &quot;菠萝手机&quot;;        String brandName = &quot;菠萝手机&quot;;        String description = &quot;美国有苹果，中国有菠萝，菠萝手机&quot;;        int ordered = 114514;        //封装成对象        Brand brand = new Brand();        brand.setStatus(status);        brand.setCompanyName(companyName);        brand.setBrandName(brandName);        brand.setDescription(description);        brand.setOrdered(ordered);        //1.获取对应的sqlsessionFactory对象        String resource = &quot;mybatis-config.xml&quot;;        InputStream inputStream = Resources.getResourceAsStream(resource);        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);        //获取sqlsession对象        SqlSession sqlSession = sqlSessionFactory.openSession();        //获取Mapper接口代理对象        BrandMapper mapper = sqlSession.getMapper(BrandMapper.class);        //执行方法        mapper.add(brand);        //提交事务        sqlSession.commit();        //释放资源        sqlSession.close();    &#125;\n\n注意：\n通过sqlSessionFactory.openSession()获取sqlSession对象时会默认开启事务，如果最后不提交事务，数据就无法添加到数据库，两种解决方法\n\n\nopenSession(true)：可以设置为自动提交事务\n在最后手动提交事务： sqlSession.commit();\n\n添加后返回主键返回添加数据的主键：\n&lt;insert id=&quot;add&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;    insert into tb_brand (brand_name,company_name,ordered,description,status)    values (#&#123;brandName&#125;,#&#123;companyName&#125;,#&#123;ordered&#125;,#&#123;description&#125;,#&#123;status&#125;) ;&lt;/insert&gt;\n\n\n\n4.4完成修改操作4.4.1修改全部字段Mapper接口添加方法\nint update(Brand brand);\n\nMapperXML添加对应的sql语句\n&lt;update id=&quot;update&quot;&gt;    update tb_brand set brand_name = #&#123;brandName&#125;,company_name = #&#123;companyName&#125;,ordered = #&#123;ordered&#125;,                        description = #&#123;description&#125;,status = #&#123;status&#125; where id = #&#123;id&#125;&lt;/update&gt;\n\n测试添加方法\n@Test    public void testUpdate() throws IOException &#123;        //获取参数        int status = 0;        String companyName = &quot;河南菠萝手机有限公司&quot;;        String brandName = &quot;菠萝手机&quot;;        String description = &quot;美国有苹果，中国有菠萝，菠萝手机～&quot;;        int ordered = 114;        int id = 11;        //封装成对象        Brand brand = new Brand();        brand.setStatus(status);        brand.setCompanyName(companyName);        brand.setBrandName(brandName);        brand.setDescription(description);        brand.setOrdered(ordered);        brand.setId(id);        //1.获取对应的sqlsessionFactory对象        String resource = &quot;mybatis-config.xml&quot;;        InputStream inputStream = Resources.getResourceAsStream(resource);        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);        //获取sqlsessionduix        SqlSession sqlSession = sqlSessionFactory.openSession();        //获取Mapper接口代理对象        BrandMapper mapper = sqlSession.getMapper(BrandMapper.class);        //执行方法        int update = mapper.update(brand);        System.out.println(update);        //提交事务        sqlSession.commit();        //释放资源        sqlSession.close();    &#125;\n\n4.4.2修改动态字段稍微修改下上面的sql语句就好\n标签可以解决很多问题\n&lt;update id=&quot;update&quot;&gt;    update tb_brand    &lt;set&gt;        &lt;if test=&quot;brandName != null and brandName != &#x27;&#x27;&quot;&gt;            brand_name = #&#123;brandName&#125;,        &lt;/if&gt;        &lt;if test=&quot;companyName != null and companyName != &#x27;&#x27;&quot;&gt;            company_name = #&#123;companyName&#125;,        &lt;/if&gt;        &lt;if test=&quot;ordered != null and ordered != &#x27;&#x27;&quot;&gt;            ordered = #&#123;ordered&#125;,        &lt;/if&gt;        &lt;if test=&quot;description != null and description != &#x27;&#x27;&quot;&gt;            description = #&#123;description&#125;,        &lt;/if&gt;        &lt;if test=&quot;status != null and status != &#x27;&#x27;&quot;&gt;            status = #&#123;status&#125;        &lt;/if&gt;    &lt;/set&gt;    where id = #&#123;id&#125;&lt;/update&gt;\n\n4.5完成删除操作4.5.1 删除单个Mapper接口添加方法\nint deleteById(int id);\n\nMapperXML添加对应的sql语句\n&lt;delete id=&quot;deleteById&quot;&gt;    delete from tb_brand where id = #&#123;id&#125;;&lt;/delete&gt;\n\n测试删除方法\n@Testpublic void testDelete() throws IOException &#123;    //获取参数    int id = 12;    //1.获取对应的sqlsessionFactory对象    String resource = &quot;mybatis-config.xml&quot;;    InputStream inputStream = Resources.getResourceAsStream(resource);    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);    //获取sqlsessionduix    SqlSession sqlSession = sqlSessionFactory.openSession();    //获取Mapper接口代理对象    BrandMapper mapper = sqlSession.getMapper(BrandMapper.class);    //执行方法    int delete = mapper.deleteById(id);    System.out.println(id);    //提交事务    sqlSession.commit();    //释放资源    sqlSession.close();&#125;\n\n\n\n4.5.2批量删除 需要将要删除的id放到一个数组里面，然后通过MyBatis的foreach标签遍历传入的数组执行sql语句\nMapper接口添加方法\n//使用注解可以解决sql语句传入keyint deleteByIds(@Param(&quot;ids&quot;) int[] ids);\n\nMapperXML添加对应的sql语句\ncollection：要遍历的数组\nitem：value\nseparator：分隔符\nopen：开始的标示符\nclose：结束的标示符\n&lt;!-- collection默认传入的是一个集合的key，前面使用了@Param(&quot;ids&quot;)注解，所以直接传入注解里的内容就好 --&gt;    &lt;delete id=&quot;deleteByIds&quot;&gt;        delete from tb_brand where id in &lt;foreach collection=&quot;ids&quot; item=&quot;id&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot;&gt;#&#123;id&#125;&lt;/foreach&gt;    &lt;/delete&gt;\n\n5.Mybatis的参数传递Mybatis 接口方法中可以接收各种各样的参数，如下：\n\n多个参数\n单个参数：单个参数又可以是如下类型\nPOJO 类型\nMap 集合类型\nCollection 集合类型\nList 集合类型\nArray 类型\n其他类型\n\n\n\n5.1 多个参数Mybatis接收多个参数需要使用 @Param 注解，那么为什么要加该注解呢？\nUser select(@Param(&quot;username&quot;) String username,@Param(&quot;password&quot;) String password);\n\n&lt;select id=&quot;select&quot; resultType=&quot;user&quot;&gt;\tselect *    from tb_user    where     \tusername=#&#123;username&#125;    \tand password=#&#123;password&#125;&lt;/select&gt;\n\n我们在接口方法中定义多个参数，Mybatis 会将这些参数封装成 Map 集合对象，值就是参数值，而键在没有使用 @Param 注解时有以下命名规则：\n\n以 arg 开头  ：第一个参数就叫 arg0，第二个参数就叫 arg1，以此类推。如：\n\nmap.put(“arg0”，参数值1);\nmap.put(“arg1”，参数值2);\n\n\n以 param 开头 ： 第一个参数就叫 param1，第二个参数就叫 param2，依次类推。如：\n\nmap.put(“param1”，参数值1);\nmap.put(“param2”，参数值2);\n\n\n\n代码验证：\n\n在 UserMapper 接口中定义如下方法\nUser select(String username,String password);\n\n在 UserMapper.xml 映射配置文件中定义SQL\n&lt;select id=&quot;select&quot; resultType=&quot;user&quot;&gt;\tselect *    from tb_user    where     \tusername=#&#123;arg0&#125;    \tand password=#&#123;arg1&#125;&lt;/select&gt;\n\n或者\n&lt;select id=&quot;select&quot; resultType=&quot;user&quot;&gt;\tselect *    from tb_user    where     \tusername=#&#123;param1&#125;    \tand password=#&#123;param2&#125;&lt;/select&gt;\n\n\n在映射配合文件的SQL语句中使用用 arg 开头的和 param 书写，代码的可读性会变的特别差，此时可以使用 @Param 注解。\n\n\n代码验证：\n\n在 UserMapper 接口中定义如下方法，在 username 参数前加上 @Param 注解\nUser select(@Param(&quot;username&quot;) String username, String password);\n\nMybatis 在封装 Map 集合时，键名就会变成如下：\n\nmap.put(“username”，参数值1);\nmap.put(“arg1”，参数值2);\nmap.put(“param1”，参数值1);\nmap.put(“param2”，参数值2);\n\n\n在 UserMapper.xml 映射配置文件中定义SQL\n&lt;select id=&quot;select&quot; resultType=&quot;user&quot;&gt;\tselect *    from tb_user    where     \tusername=#&#123;username&#125;    \tand password=#&#123;param2&#125;&lt;/select&gt;\n\n运行程序结果没有报错。而如果将 #&#123;&#125; 中的 username 还是写成  arg0 \n&lt;select id=&quot;select&quot; resultType=&quot;user&quot;&gt;\tselect *    from tb_user    where     \tusername=#&#123;arg0&#125;    \tand password=#&#123;param2&#125;&lt;/select&gt;\n\n运行程序则可以看到错误\n\n\n\n结论：以后接口参数是多个时，在每个参数上都使用 @Param 注解。这样代码的可读性更高。\n5.2 单个参数\nPOJO 类型\n直接使用。要求 属性名 和 参数占位符名称 一致\n\nMap 集合类型\n直接使用。要求 map集合的键名 和 参数占位符名称 一致\n\nCollection 集合类型\nMybatis 会将集合封装到 map 集合中，如下：\n\nmap.put(“arg0”，collection集合);\nmap.put(“collection”，collection集合;\n\n&#x3D;&#x3D;可以使用 @Param 注解替换map集合中默认的 arg 键名。&#x3D;&#x3D;\n\nList 集合类型\nMybatis 会将集合封装到 map 集合中，如下：\n\nmap.put(“arg0”，list集合);\nmap.put(“collection”，list集合);\nmap.put(“list”，list集合);\n\n&#x3D;&#x3D;可以使用 @Param 注解替换map集合中默认的 arg 键名。&#x3D;&#x3D;\n\nArray 类型\nMybatis 会将集合封装到 map 集合中，如下：\n\nmap.put(“arg0”，数组);\nmap.put(“array”，数组);\n\n&#x3D;&#x3D;可以使用 @Param 注解替换map集合中默认的 arg 键名。&#x3D;&#x3D;\n\n其他类型\n比如int类型，参数占位符名称 叫什么都可以。尽量做到见名知意\n\n\n6.注解实现CRUDMybatis 针对 CURD 操作都提供了对应的注解，已经做到见名知意。如下：\n\n查询 ：@Select\n\n添加 ：@Insert\n\n修改 ：@Update\n\n删除 ：@Delete\n\n\n案例\nUserMapper\n@Select(&quot;select * from tb_user where id = #&#123;id&#125;&quot;)    User selectById(int id);\n\npublic class UserMapperTest &#123;    public static void main(String[] args) throws IOException &#123;        //加载mybatis的核心配置文件 获取sqlsessionFactory        String resource = &quot;mybatis-config.xml&quot;;        InputStream inputStream = Resources.getResourceAsStream(resource);        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);        //获取sqlsession对象        SqlSession sqlSession = sqlSessionFactory.openSession();        //执行sql语句        //获取usermapper接口的代理对象        UserMapper mapper = sqlSession.getMapper(UserMapper.class);        User user = mapper.selectById(1);        System.out.println(user);        //释放资源        sqlSession.close();    &#125;&#125;\n\n在官方文档中 入门 中有这样的一段话：\n\n使用注解来映射简单语句会使代码显得更加简洁，但对于稍微复杂一点的语句，Java 注解不仅力不从心，还会让你本就复杂的 SQL 语句更加混乱不堪。 因此，如果你需要做一些很复杂的操作，最好用 XML 来映射语句。\n选择何种方式来配置映射，以及认为是否应该要统一映射语句定义的形式，完全取决于你和你的团队。 换句话说，永远不要拘泥于一种方式，你可以很轻松的在基于注解和 XML 的语句映射方式间自由移植和切换。\n\n所以 注解完成简单功能，配置文件完成复杂功能。\n","tags":["学习笔记"]},{"title":"Java基础学习笔记","url":"/2022/01/15/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"1. java语言概述1.1 java语言概述1.1.1 什么是软件\n软件：一系列按照特定顺序组织的计算机数据和指令的集合。分为：\n系统软件：windows , mac os , linux ,unix,android,ios……\n应用软件：word ,ppt,画图板,…\n\n\n人机交互方式：\n图形化界面(Graphical User Interface GUI)\n命令行方式(Command Line Interface CLI)\n\n\n\n1.1.2 常用DOS命令dir :列出当前目录下的文件以及文件夹md:创建目录rd :删除目录cd:进入指定目录cd.. :  退回到上一级目录cd:退回到根目录del :删除文件exit : 退出dos 命令行补充：echo javase&gt;1.doc\n1.1.3 计算机语言的发展迭代史\n第一代语言：机器语言。指令以二进制代码形式存在。\n第二代语言：汇编语言。使用助记符表示一条机器指令。\n第三代语言：高级语言，java c c++等语言\n\n1.1.4 Java语言版本迭代概述1991年Green项目，开发语言最初命名为Oak (橡树)1994年，开发组意识到Oak 非常适合于互联网1996年，发布JDK 1.0，约8.3万个网页应用Java技术来制作1997年，发布JDK 1.1，JavaOne会议召开，创当时全球同类会议规模之最1998年，发布JDK 1.2，同年发布企业平台J2EE1999年，Java分成J2SE、J2EE和J2ME，JSP&#x2F;Servlet技术诞生2004年，发布里程碑式版本：JDK 1.5，为突出此版本的重要性，更名为JDK 5.02005年，J2SE -&gt; JavaSE，J2EE -&gt; JavaEE，J2ME -&gt; JavaME2009年，Oracle公司收购SUN，交易价格74亿美元2011年，发布JDK 7.02014年，发布JDK 8.0，是继JDK 5.0以来变化最大的版本2017年，发布JDK 9.0，最大限度实现模块化2018年3月，发布JDK 10.0，版本号也称为18.32018年9月，发布JDK 11.0，版本号也称为18.9\n1.1.5 Java语言应用的领域\n企业级应用：主要指复杂的大企业的软件系统、各种类型的网站。\n\nAndroid平台应用：Android应用程序使用Java语言编写。\n\n大数据平台开发：各类框架Hadoop，spark，storm，flink等，就这类技术生态\n\n\n1.1.6 Java语言的特点\n面向对象性：两个要素：类、对象​    三个特征：封装、继承、多态\n\n健壮性：① 去除了C语言中的指针 ②自动的垃圾回收机制 –&gt;仍然会出现内存溢出、内存泄漏\n\n跨平台型：write once,run anywhere:一次编译，到处运行\n\n\n\n\n1.2 开发环境搭建1.2.1 JDK 、JRE 、JVM的关系\n\nJDk &#x3D; JRE + java开发工具(java javac javadoc……)\nJRE &#x3D; JVM + javaSE常用类库\nJVM &#x3D; Java运行虚拟机\n\n\n1.2.2  JDK的下载、安装、配置环境变量\n下载：Oracle官网 下载想要的版本\n\n安装：傻瓜式安装：JDK 、JRE  \n安装目录不建议有中文\n\n环境变量：\n\n为什么配置path环境变量？\npath环境变量：windows操作系统执行命令时所要搜寻的路径\n为什么要配置path:希望java的开发工具（javac.exe,java.exe)在任何的文件路径下都可以执行成功。\n\n\n如何配置：\n环境变量 —&gt; 新建环境变量 —&gt; 变量名：JAVA_HOME —&gt;变量值：jdk安装路径\n环境变量 —&gt; path –&gt; 新建 –&gt; %JAVA_HOME%\\bin\n\n\n\n\n\n1.3 第一个JAVA程序1.3.1 HelloWorld\n编写\n创建一个文件：HelloWorld.java\n\n\npublic class HelloWorld&#123;    public static void main(String args)&#123;        System.out.println(&quot;HelloWorld&quot;);    &#125;&#125;\n\n\n编译\njavac HelloWorld.java\n\n运行\njava HelloWorld\n\n\n1.3.2 常见问题解决\n\n1.3.3 总结第一个程序\n1.java程序编写-编译-运行的过程\n编写：我们将编写的java代码保存在以”.java”结尾的源文件中\n编译：使用javac.exe命令编译我们的java源文件。格式：javac 源文件名.java\n运行：使用java.exe命令解释运行我们的字节码文件。 格式：java 类名\n\n2.在一个java源文件中可以声明多个class。但是，只能最多有一个类声明为public的。而且要求声明为public的类的类名必须与源文件名相同。\n\n3.程序的入口是main()方法。格式是固定的。\n\n4.输出语句：System.out.println():先输出数据，然后换行System.out.print():只输出数据\n\n5.每一行执行语句都以”;”结束。\n\n6编译的过程：编译以后，会生成一个或多个字节码文件。字节码文件的文件名与java源文件中的类名相同。\n\n\n1.4 注释与API文档1.4.1 注释\n分类\n\n单行注释：&#x2F;&#x2F;\n\n多行注释：&#x2F;*    *&#x2F;\n\n文档注释：&#x2F;**    *&#x2F;\n\n注释内容可以被JDK提供的工具JAVAdoc所解析，生成一套以网页形式体现的该程序的说明文档\n\n操作方式：\njavadoc -d mydoc -author -version HelloWorld.java\n\n\n\n\n作用\n\n对所写的程序进行解释说明，增强可读性。方便自己，方便别人\n调试所写的代码\n\n\n特点：\n\n单行注释和多行注释，注释了的内容不参与编译。  换句话说，编译以后生成的.class结尾的字节码文件中不包含注释掉的信息\n注释内容可以被JDK提供的工具 javadoc 所解析，生成一套以网页文件形式体现的该程序的说明文档。\n多行注释不可以嵌套使用\n\n\n\n1.4.2 Java API文档\nAPI:application programming interface。习惯上：将语言提供的类库，都称为api.\nAPI文档：针对于提供的类库如何使用，给的一个说明书。类似于《新华字典》\n\n1.4.3 良好的编程风格\n\n2.基本语法2.1 关键字与标识符2.1.1 java关键字的使用定义：被Java语言赋予了特殊含义，用做专门用途的字符串（单词）\n特点：关键字中所字母都为小写\n具体哪些关键字：\n\n\n2.1.2 保留字定义：现Java版本尚未使用，但以后版本可能会作为关键字使用。\n具体哪些保留字：goto 、const\n注意：自己命名标识符时要避免使用这些保留字\n2.1.3 标识符的使用定义：凡是自己可以起名字的地方都叫标识符。\n涉及到的结构：包名、类名、接口名、变量名、方法名、常量名\n规则：必须要遵守。否则，编译不通过\n\n由由26个字母大小写，数字1-9，_和$组成\n不能用数字开头\n不能使用java关键字和保留字，但能包含关键字和保留字\n严格区分大小写，长度无限制\n标识符不能包含空格规范\n\n规范：可以不遵守，不影响编译和运行。但是要求大家遵守\n\n包名：多单词组成时所有字母小写：xxyyzz\n类名、接口名：多单词组成时。所有单词首字母大写：XxYyZz\n变量名、方法名：多单词组成时，第一个单词首字母小写，剩下的每个单词首字母大写：xxYyZZ\n常量名：所有首字母大写\n\n注意点： 在起名字时，为了提高阅读性，要尽量意义，“见名知意”。\n2.2 变量的使用2.2.1 变量的分类1.按数据类型分类\n详细说明\n整形：\n\nbyte (1字节&#x3D;8bit) (范围：128 ~ -127)\nshort (2字节)\nint (4字节)   (通常，定义整型变量时，使用int型。) (整型的常量，默认类型是：int型)\n\n\nlong (8字节) (声明long型变量，必须以”l”或”L”结尾)\n\n\n浮点型：表示带小数点的数值\n\nfloat (4字节) (float表示数值的范围比long还大) (定义float类型变量时，变量要以”f”或”F”结尾)\ndouble (8字节) (通常，定义浮点型变量时，使用double型。) (浮点型的常量，默认类型为：double)\n\n\n字符型：\n\nchar (1字符&#x3D;2字节) （定义char型变量，通常使用一对’’,内部只能写一个字符）\n\n\n布尔型：\n\nboolean (只能取两个值之一：true 、 false) (常常在条件判断、循环结构中使用)\n\n\n\n2.按声明的位置分类(了解)\n2.2.2 定义变量的格式\n第一种\n//数据类型  变量名 = 变量值；int num = 12;\n\n第二种\n//数据类型 变量名//变量名 = 变量值;int num;num = 12;\n\n注意点\n\n变量必须先声明，后使用\n变量都定义在其作用域内。在作用域内，它是有效的。换句话说，出了作用域，就失效了\n同一个作用域内，不可以声明两个同名的变量\n\n\n\n2.2.3 基本数据类型变量间运算规则\n涉及到的基本数据类型：除了boolean之外的其他7种\n\n自动类型转换(只涉及7种基本数据类型）\n\nbyte 、char 、short –&gt; int –&gt; long –&gt; float –&gt; double \n特别的：当byte、char、short三种类型的变量做运算时，结果为int型\n说明：此时的容量大小指的是，表示数的范围的大和小。比如：float容量要大于long的容量\n\n\n结论：当容量小的数据类型的变量与容量大的数据类型的变量做运算时，结果自动提升为容量大的数据类型。\n\n强制类型转换 ：自动类型提升运算的逆运算。\n\n只涉及7种基本数据类型\n\n需要使用强转符：()\ndouble b1 = 123.45;int num = (double)b1;//123\n\n注意点：强制类型转换，可能导致精度损失。\n\n\n\nString与8种基本数据类型间的运算\n\nString属于引用数据类型,翻译为：字符串\n声明String类型变量时，使用一对””\nString可以和8种基本数据类型变量做运算，且运算只能是连接运算：+\n运算的结果仍然是String类型\n\n\n\n2.3进制(了解)2.3.1 编程中涉及的进制及表示方式：\n二进制（binary）：0 1，满2进1，以0b或0B开头\n十进制（decimal）：0-9，满10进1\n八进制（octal）：满八进一，以数字0开头\n十六进制（hex）：0-9及A-F，满16进1，以0x或0X开头表示，此处A-F不区分大小写\n\n2.3.2 二进制的使用说明：\n计算机底层的存储方式：所有数字在计算机底层都以二进制形式存在。\n二进制数据的存储方式：所有的数值，不管正负，底层都以补码的方式存储。\n2.3 原码、反码、补码的说明：\n正数：三码合一\n负数：\n\n\n\n2.3.3 进制间的转换\n二进制转十进制\n\n\n\n十进制转二进制\n\n\n\n2.4 运算符2.4.1 算术运算符\n\n\n运算符\n运算\n范例\n结果\n\n\n\n+\n正号\n+3\n3\n\n\n-\n负号\nb&#x3D;4; -b\n-4\n\n\n+\n加\n5+5\n10\n\n\n-\n减\n6-4\n2\n\n\n*****\n乘\n3*4\n12\n\n\n&#x2F;\n除\n5&#x2F;5\n1\n\n\n%\n取模(取余)\n7%5\n2\n\n\n++\n自增（前）：先运算后取值 自增（后）：先取值后运算\na&#x3D;2;b&#x3D;++a; a&#x3D;2;b&#x3D;a++;\na&#x3D;3;b&#x3D;3 a&#x3D;3;b&#x3D;2\n\n\n-  -\n自减（前）：先运算后取值  自减（后）：先取值后运算\na&#x3D;2;b&#x3D;-  -a  a&#x3D;2;b&#x3D;a-  -\na&#x3D;1;b&#x3D;1  a&#x3D;1;b&#x3D;2\n\n\n+\n字符串连接\n“He”+”llo”\n“Hello”\n\n\nint num1 = 12;int num2 = 6;int result1 = num1 + num2;int result2 = num1 - num2;int result3 = num1 * num2;int result4 = num1 / num2;// %:取余运算//结果的符号与被模数的符号相同//开发中，经常使用%来判断能否被除尽的情况。int result5 = num1 % num2;int a3 = 10;++a3;int b3 =a3;//++a；先加一，后运算//a++；先运算，后加一System.out.println(result1);System.out.println(result2);System.out.println(result3);System.out.println(result4);System.out.println(result5);System.out.println(a3);System.out.println(b3);\n\n2.4.2 赋值运算符\n\n\n运算符\n运算\n范例\n结果\n\n\n\n&#x3D;\n赋值\na&#x3D;1\n1\n\n\n+&#x3D;\n加并赋值\na+&#x3D;1\n1+1&#x3D;2\n\n\n-&#x3D;\n减并赋值\na-&#x3D;1\n2-1&#x3D;1\n\n\n*&#x3D;\n乘并赋值\na*&#x3D;1\n1*1&#x3D;1\n\n\n&#x2F;&#x3D;\n除并赋值\na&#x2F;&#x3D;1\n1&#x2F;1&#x3D;1\n\n\n%&#x3D;\n取余并赋值\na%&#x3D;1\n1%1&#x3D;0\n\n\nint i2,j2;//连续赋值fang shii2 = j2 = 10;//***************int i3 = 10,j3 = 20;int num1 = 10;num1 += 2;//num1 = num1 + 2;System.out.println(num1);//12int num2 = 12;num2 %= 5;//num2 = num2 % 5;System.out.println(num2);short s1 = 10;//s1 = s1 + 2;//编译失败s1 += 2;//结论：不会改变变量本身的数据类型System.out.println(s1);\n\n\n运算的结果不会改变变量本身的数据类型\n开发中，如果希望变量实现+2的操作，有几种方法？(前提：int num &#x3D; 10;)\n\n​\t\t方式一：num &#x3D; num + 2;\n​\t\t方式二：num +&#x3D; 2; (推荐)\n\n&#x2F;&#x2F;开发中，如果希望变量实现+1的操作，有几种方法？(前提：int num &#x3D; 10;)\n\n​\t\t方式一：num &#x3D; num + 1;\n​\t\t方式二：num +&#x3D; 1; \n​\t\t方式三：num++; (推荐)\n2.4.3 比较运算符\n\n\n运算符\n运算\n范例\n结果\n\n\n\n&#x3D;&#x3D;\n相等于\n4&#x3D;&#x3D;3\nfalse\n\n\n!&#x3D;\n不等于\n4!&#x3D;3\ntrue\n\n\n&lt;\n小于\n4&lt;3\nfalse\n\n\n&gt;\n大于\n4&gt;3\ntrue\n\n\n&lt;&#x3D;\n小于等于\n4&lt;&#x3D;3\nfalse\n\n\n&gt;&#x3D;\n大于等于\n4&gt;&#x3D;3\ntrue\n\n\ninstanceof\n检查是否是类的对象\n“Hello” instanceof String\ntrue\n\n\nint i = 10;int j = 20;System.out.println(i == j);//falseSystem.out.println(i = j);//20boolean b1 = true;boolean b2 = false;System.out.println(b2 == b1);//falseSystem.out.println(b2 = b1);//true\n\n\n比较运算符的结果是boolean类型\n比较运算符“&#x3D;&#x3D;”不能误写成“&#x3D;” 。\n&gt;   &lt;    &gt;&#x3D;    &lt;&#x3D; :只能使用在数值类型的数据之间。\n&#x3D;&#x3D; 和 !&#x3D;: 不仅可以使用在数值类型数据之间，还可以使用在其他引用类型变量之间。\n\n2.4.4 逻辑运算符\n\n\n&amp;—逻辑与\n| —逻辑或\n！—逻辑非\n\n\n\n&amp;&amp; —短路与\n|| —短路或\n^ —逻辑异或\n\n\n\n\n\na\nb\na&amp;b\na&amp;&amp;b\na|b\na||b\n!a\na^b\n\n\n\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\nfalse\n\n\ntrue\nfalse\nfalse\nfalse\ntrue\ntrue\nfalse\ntrue\n\n\nfalse\ntrue\nfalse\nfalse\ntrue\ntrue\ntrue\ntrue\n\n\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\ntrue\nfalse\n\n\n//开发中，推荐使用&amp;&amp;\t\tboolean b1 = true;\t\tb1 = false;\t\tint num1 = 10;s\t\tif(b1 &amp; (num1++ &gt; 0))&#123;\t\t\tSystem.out.println(&quot;我现在在北京&quot;);\t\t&#125;else&#123;\t\t\tSystem.out.println(&quot;我现在在南京&quot;);\t\t&#125;\t\tSystem.out.println(&quot;num1 = &quot; + num1);\t\t\t\tboolean b2 = true;\t\tb2 = false;\t\tint num2 = 10;\t\tif(b2 &amp;&amp; (num2++ &gt; 0))&#123;\t\t\tSystem.out.println(&quot;我现在在北京&quot;);\t\t&#125;else&#123;\t\t\tSystem.out.println(&quot;我现在在南京&quot;);\t\t&#125;\t\tSystem.out.println(&quot;num2 = &quot; + num2);\n\n\n逻辑运算符操作的都是boolean类型的变量。而且结果也是boolean类型\n\n&amp;和&amp;&amp;的区别：\n\n单&amp;时，左边无论真假，右边都进行运算；\n\n双&amp;时，如果左边为真，右边参与运算，如果左边为假，那么右边不参与运算。\n\n\n\n|和||的区别同理，||表示：当左边为真，右边不参与运算。\n\n异或( ^ )与或( | )的不同之处是：当左右都为true时，结果为false。 理解：异或，追求的是“异”!\n\n\n2.4.5 位运算符(了解)\n\n\n运算符\n运算\n范例\n\n\n\n&lt;&lt;\n左移\n3 &lt;&lt; 2 &#x3D; 12 –&gt; 322&#x3D;12\n\n\n&gt;&gt;\n右移\n3 &gt;&gt; 1 &#x3D; 1 –&gt; 3&#x2F;2&#x3D;1\n\n\n&gt;&gt;&gt;\n无符号右移\n3 &gt;&gt;&gt; 1 &#x3D; 1 –&gt; 3&#x2F;2&#x3D;1\n\n\n&amp;\n与运算\n6 &amp; 3 &#x3D; 2\n\n\n|\n或运算\n6 | 3 &#x3D; 7\n\n\n^\n异或运算\n6 ^ 3 &#x3D; 5\n\n\n~\n取反运算\n~6 &#x3D; -7\n\n\nint i = 21;i = -21;System.out.println(&quot;i &lt;&lt; 2 :&quot; + (i &lt;&lt; 2));System.out.println(&quot;i &lt;&lt; 3 :&quot; + (i &lt;&lt; 3));System.out.println(&quot;i &lt;&lt; 27 :&quot; + (i &lt;&lt; 27));int m = 12;int n = 5;System.out.println(&quot;m &amp; n :&quot; + (m &amp; n));System.out.println(&quot;m | n :&quot; + (m | n));System.out.println(&quot;m ^ n :&quot; + (m ^ n));//【面试题】 你能否写出最高效的2 * 8的实现方式？ 答案：2 &lt;&lt; 3    或    8 &lt;&lt; 1\n\n\n位运算符操作的都是整型的数据\n\n&lt;&lt; ：在一定范围内，每向左移1位，相当于 * 2\n  &gt;&gt; :在一定范围内，每向右移1位，相当于 &#x2F; 2\n\n\n2.4.6 三元运算符\n//两格数求大的那个数int num1 = 15;int num2 = 20;int max = (num1 &gt; num2)? num1 : num2;System.out.println(max);\n\n\n条件表达式的结果为boolean类型\n\n根据条件表达式真或假，决定执行表达式1，还是表达式2.\n    如果表达式为true，则执行表达式1。\n    如果表达式为false，则执行表达式2。\n\n表达式1 和表达式2要求是一致的。\n\n三元运算符可以嵌套使用\n\n凡是可以使用三元运算符的地方，都可以改写为if-else\n反之，不成立。\nint num1 = 145;String s1 = &quot;哈哈哈&quot;;//(num1 &gt; s1)? num1 &gt; s1;报错\n\n\n\n如果程序既可以使用三元运算符，又可以使用if-else结构，那么优先选择三元运算符。原因：简洁、执行效率高。\n\n\n\n2.5 流程控制2.5.1 分支结构1. if-else条件判断结构\n\n/*结构一：    if(条件表达式)&#123;        执行表达式    &#125;*/if(a&gt;b)&#123;    System.out.println(a);&#125;/*结构二：二选一    if(条件表达式)&#123;        执行表达式1    &#125;else&#123;        执行表达式2    &#125;*/if(a&gt;b)&#123;    System.out.println(a);&#125;else&#123;    System.out.println(b);&#125;/*结构三：n选一    if(条件表达式)&#123;        执行表达式1    &#125;else if(条件表达式)&#123;        执行表达式2    &#125;else if(条件表达式)&#123;        执行表达式3    &#125;....*/if(a&gt;b)&#123;    System.out.println(a+b);&#125;else if(a&lt;b)&#123;    System.out.println(a-b);&#125;else if(a == b)&#123;    System.out.println(a*b);&#125;\n\n\nelse 结构是可选的。\n针对于条件表达式：\n如果多个条件表达式之间是“互斥”关系(或没有交集的关系),哪个判断和执行语句声明在上面还是下面，无所谓。\n如果多个条件表达式之间有交集的关系，需要根据实际情况，考虑清楚应该将哪个结构声明在上面。\n如果多个条件表达式之间有包含的关系，通常情况下，需要将范围小的声明在范围大的上面。否则，范围小的就没机会执行了。\n\n\nif-else结构是可以相互嵌套的。\n如果if-else结构中的执行语句只有一行时，对应的一对{}可以省略的。但是，不建议大家省略。\n\n2. switch-case选择结构/*switch(表达式)&#123;    case 常量1:        执行语句1;        //break;    case 常量2:        执行语句2;        //break;    ...    default:        执行语句n;        //break;    &#125;*/class SwitchTest&#123;\tpublic static void main(String[] args)&#123;\t\tint number = 2;\t\tswitch(number)&#123;\t\tcase 0:\t\t\tSystem.out.println(&quot;zero&quot;);\t\t\tbreak;\t\tcase 1:\t\t\tSystem.out.println(&quot;one&quot;);\t\t\tbreak;\t\tcase 2:\t\t\tSystem.out.println(&quot;twe&quot;);\t\t\tbreak;\t\tcase 3:\t\t\tSystem.out.println(&quot;three&quot;);\t\t\tbreak;\t\tdefault:\t\t\tSystem.out.println(&quot;other&quot;);\t\t\tbreak;\t\t&#125;\n\n\n根据switch表达式中的值，依次匹配各个case中的常量。一旦匹配成功，则进入相应case结构中，调用其执行语句。\n当调用完执行语句以后，则仍然继续向下执行其他case结构中的执行语句，直到遇到break关键字或此switch-case结构末尾结束为止。\n\nbreak,可以使用在switch-case结构中，表示一旦执行到此关键字，就跳出switch-case结构\n\nswitch结构中的表达式，只能是如下的6种数据类型之一：   byte 、short、char、int、枚举类型(JDK5.0新增)、String类型(JDK7.0新增)\n\ncase 之后只能声明常量。不能声明范围。\n\nbreak关键字是可选的。\n\ndefault:相当于if-else结构中的else.default结构是可选的，而且位置是灵活的。\n\n如果switch-case结构中的多个case的执行语句相同，则可以考虑进行合并。\n\nbreak在switch-case中是可选的\n\n\n2.5.2 循环结构1. 循环四要素\n\n初始化条件\n\n初始化条件\n\n循环条件 —&gt;是boolean类型\n\n循环体\n\n迭代条件\n说明：通常情况下，循环结束都是因为②中循环条件返回false了。\n\n\n2. 三种循环结构1. for循环结构/*for(1;2;4)&#123;\t3&#125;执行过程：① - ② - ③ - ④ - ② - ③ - ④ - ... - ②*/for(int = 1; i&lt;=100;i++)&#123;    System.out.println(i);&#125;\n\n2. while循环结构/*1while(2)&#123;\t3;\t4;&#125;执行过程：① - ② - ③ - ④ - ② - ③ - ④ - ... - ②写while循环千万小心不要丢了迭代条件。一旦丢了，就可能导致死循环！*/int i = 1;while(i&gt;=100)&#123;    System.out.println(i);    i++;&#125;\n\n\n开发中，基本上我们都会从for、while中进行选择，实现循环结构。\n\nfor循环和while循环是可以相互转换的！\n区别：for循环和while循环的初始化条件部分的作用范围不同。\n\n写程序，要避免出现死循环。\n\n\n3. do-while循环结构/*1do&#123;\t3;\t4;&#125;while(2);执行过程：① - ③ - ④ - ② - ③ - ④ - ... - ②*/int i =1;do&#123;\tSystem.out.println(i);\ti++;&#125;while(2)\n\n\ndo-while循环至少会执行一次循环体！\n开发中，使用for和while更多一些。较少使用do-while\n\n4.”无限“循环结构：while(true) 或  for(;;)如何结束一个循环结构？\n\n方式一：当循环条件是false时\n方式一：当循环条件是false时\n\n5. 嵌套循环  嵌套循环：将一个循环结构A声明在另一个循环结构B的循环体中,就构成了嵌套循环\n  内层循环：循环结构A\n  外层循环：循环结构B\n\n\n内层循环结构遍历一遍，只相当于外层循环循环体执行了一次\n\n假设外层循环需要执行m次，内层循环需要执行n次。此时内层循环的循环体一共执行了m * n次\n\n外层循环控制行数，内层循环控制列数\n\n\npublic class ForForTest &#123;    public static void main(String[] args) &#123;        /*        *****\t\t*****\t\t*****\t\t*****\t\t*****        */        for (int i = 0; i &lt; 5; i++) &#123;            for (int j = 0; j &lt; 5; j++) &#123;                System.out.print(&quot;*&quot;);            &#125;            System.out.println();        &#125;        /*        *\t\t**\t\t***\t\t****\t\t*****        */        for (int i = 0; i &lt; 5; i++) &#123;            for (int j = 0; j &lt;= i; j++) &#123;                System.out.print(&quot;*&quot;);            &#125;            System.out.println();        &#125;        System.out.println(&quot;-------------------------&quot;);        /*        *****\t\t****\t\t***\t\t**\t\t*        */        for (int i = 0; i &lt; 5; i++) &#123;            for (int j = 5 - i; j &gt;= 1; j--) &#123;                System.out.print(&quot;*&quot;);            &#125;            System.out.println();        &#125;        System.out.println(&quot;-------------------------&quot;);        /*        *\t\t***\t\t*****\t\t*******\t\t*****\t\t***\t\t*        */        for (int i = 1; i &lt;= 4; i++) &#123;            for (int j = 2 * i - 1; j &gt;= 1; j--) &#123;                System.out.print(&quot;*&quot;);            &#125;            System.out.println();        &#125;        for (int i = 1; i &lt;= 3; i++) &#123;            for (int j = 7 - (i * 1 + 1); j &gt;= i; j--) &#123;                System.out.print(&quot;*&quot;);            &#125;            System.out.println();        &#125;        System.out.println(&quot;-------------------------&quot;);        /*            *\t\t   * *\t\t  * * *\t\t * * * *\t\t* * * * *\t\t * * * *\t\t  * * *\t\t   * *\t\t    *        */        //上半部分        for (int i = 1; i &lt;= 5; i++) &#123;            for (int j = 5 - i; j &gt;= 1; j--) &#123;                System.out.print(&quot; &quot;);            &#125;            for (int k = 1; k &lt;= i; k++) &#123;                System.out.print(&quot;*&quot; + &quot; &quot;);            &#125;            System.out.println();        &#125;        //下半部分        for (int i = 1; i &lt;= 4; i++) &#123;            for (int q = 1; q&lt;=i;q++)&#123;                System.out.print(&quot; &quot;);            &#125;            for(int j = 5-i; j&gt;=1; j--)&#123;                System.out.print(&quot;*&quot; + &quot; &quot;);            &#125;            System.out.println();        &#125;        System.out.println();    &#125;&#125;\n\n//九九乘法表for(int i = 1; i &lt;= 9; i++)&#123;    for(int j = 1; j &lt;= i; j++)&#123;        System.out.print(j + &quot;x&quot; + i + &quot;=&quot; + j * i + &quot;\\t&quot; );    &#125;    System.out.println();    &#125;\n\n\n\n2.5.3 break和continue关键字的使用1.break的使用\nbreak语句用于终止某个语句块的执行\n&#123;    \t......\tbreak;\t//后面不在执行\t......&#125;\n\nbreak语句出现在多层嵌套的语句块中时，可以通过标签指明要终止的是哪一层语句块\nlabel1:\t&#123;\t......label2:\t\t&#123;\t......label3:\t\t\t&#123;\t......    \t\t\t\t//停止label1 label2循环\t\t\t\t\tbreak label2;\t\t\t\t\t......\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\n\n2. continue的使用\ncontinue只能使用在循环结构中\ncontinue语句用于跳过其所在循环语句块的一次执行，继续下一次循环\ncontinue语句出现在多层嵌套的循环语句体中时，可以通过标签指明要跳过的是哪一层循环\n\n3. 特殊流程控制语句说明\nbreak只能用于switch语句和循环语句中。\ncontinue 只能用于循环语句中。\n二者功能类似，但continue是终止本次循环，break是终止本层循环。\nbreak、continue之后不能有其他的语句，因为程序永远不会执行其后的语句。\n标号语句必须紧接在循环的头部。标号语句不能用在非循环语句的前面。\n很多语言都有goto语句，goto语句可以随意将控制转移到程序中的任意一条语句上，然后执行它。但使程序容易出错。Java中的break和continue是不同于goto的。\n\n/*100以内的所有质数质数：素数，只能被1和它本身整除的自然数。最小的质数是：2*/class PrimeNuberTest&#123;\tpublic static void main(String[] args)&#123;\t\tboolean isFlag = true;\t//标识是否被除尽，一旦除尽，修改其值。\t\tfor(int i = 2;i &lt;= 100;i++)&#123;\t//遍历100以内的自然数\t\t\tfor(int j =2;j &lt; i;j++)&#123;\t//j:被i去除\t\t\t\tif(i % j == 0)&#123;\t//i被j除尽\t\t\t\t\tisFlag = false;\t\t\t\t&#125;\t\t\t&#125;\t\t\tif(isFlag == true)&#123;\t\t\t\tSystem.out.println(i);\t\t\t&#125;\t\t\t//重置isFlag\t\t\tisFlag = true;\t\t&#125;\t&#125;&#125;\n\n/*100000以内的所有质数质数：素数，只能被1和它本身整除的自然数。最小的质数是：2*/class PrimeNuberTest&#123;\tpublic static void main(String[] args)&#123;\t\tboolean isFlag = true;\t//标识是否被除尽，一旦除尽，修改其值。\t\tint count = 0;\t//记录质数的个数\t\t//获取当前时间举例1970-01-01 00:00:00 的毫秒数\t\tlong start = System.currentTimeMillis();\t\tfor(int i = 2;i &lt;= 100000;i++)&#123;\t//遍历100以内的自然数\t\t\t//优化2：对本身是质数的自然数有效 5447---&gt; 11\t\t//\tfor(int j =2;j &lt; i;j++)&#123;\t//j:被i去除\t\t\tfor(int j =2;j &lt;= Math.sqrt(i);j++)&#123;\t//j:被i去除\t\t\t\tif(i % j == 0)&#123;\t//i被j除尽\t\t\t\t\tisFlag = false;\t\t\t\t\tbreak;\t//优化一：只对本身非质数的自然数是有效的。\t\t\t\t&#125;\t\t\t&#125;\t\t\tif(isFlag == true)&#123;\t\t\t//\tSystem.out.println(i);\t\t\t\tcount++;\t\t\t&#125;\t\t\t//重置isFlag\t\t\tisFlag = true;\t\t&#125;\t\t//获取当前时间举例1970-01-01 00:00:00 的毫秒数\t\tlong end = System.currentTimeMillis();\t\tSystem.out.println(&quot;质数的个数:&quot; + count);\t\tSystem.out.println(&quot;所花费的时间为:&quot; + (end - start));\t//16843 --&gt; 5447\t优化一\t&#125;&#125;\n\n2.5.4 Scanner类的使用\n导包：import java.util.Scanner;\nScanner的实例化:Scanner scan &#x3D; new Scanner(System.in);\n调用Scanner类的相关方法（next() &#x2F; nextXxx()），来获取指定类型的变量\n\n\n注意：需要根据相应的方法，来输入指定类型的值。如果输入的数据类型与要求的类型不匹配时，会报异常：InputMisMatchException导致程序终止。\n\nimport java.util.Scanner;public class WhileTest01 &#123;    public static void main(String[] args) &#123;        Scanner input = new Scanner(System.in);        int positive = 0;        int negative = 0;        while (true) &#123;            System.out.print(&quot;请输入数字：&quot;);            int userInput = input.nextInt();            if (userInput &gt; 0) &#123;                System.out.println(userInput);                positive++;            &#125; else if (userInput &lt; 0) &#123;                System.out.println(userInput);                negative++;            &#125; else &#123;                break;            &#125;        &#125;        System.out.println(&quot;输入的正数有：&quot; + positive + &quot;个&quot;);        System.out.println(&quot;输入的负数有：&quot; + negative + &quot;个&quot;);    &#125;&#125;\n\n2.5.6 随机数如何获取一个随机数：10 - 99\n 使用Math.random函数\ndouble value =  Math.radom();//[0.0,1.0]double value =  Math.radom() * 100;//[0.0,100.0] 不行double value =  (int)(Math.radom() * 90 + 10)  ;//[0.0,1.0] --&gt;[0.0,90.0] --&gt;[10.0,100.0]--&gt;[10,99]\n\n 公式:[a，b] : (int)(Math.random() * (b-a+1)+a)\n\n3. 数组3.1 数组的概述3.1.1 数组的理解数组(Array)，是多个相同类型数据一定顺序排列的集合，并使用一个名字命名，并通过编号的方式对这些数据进行统一管理。\n3.1.2 数组的相关概念\n数组名\n元素\n角标、下标、索引\n数组的长度：元素的个数\n\n3.1.3 数组的特点\n数组是序排列的\n数组属于引用数据类型的变量。数组的元素，既可以是基本数据类型，也可以是引用数据类型\n创建数组对象会在内存中开辟一整块连续的空间\n创建数组对象会在内存中开辟一整块连续的空间\n\n3.1.4 数组的分类\n照维数：一维数组、二维数组、。。。\n照数组元素的类型：基本数据类型元素的数组、引用数据类型元素的数组\n\n3.2 一维数组的使用3.2.1 一维数组的声明与初始化//正确的方式int num;//声明num = 10;//初始化int arr = 1001;int[] ids;//声明//静态初始化:数组的初始化和数组元素的赋值操作同时进行ids = new int[]&#123;1001,1002,1003,1004&#125;;//动态初始化:数组的初始化和数组元素的赋值操作分开进行String[] names = new String[5];int[] arr4 = &#123;1,2,3,4,5&#125;;//类型推断错误的方式：//int[] arr1 = new int[];//int[5] arr2 = new int[5];//int[] arr3 = new int[3]&#123;1,2,3&#125;;\n\n3.2.2 一维数组元素的引用一维数组元素的引用：通过角标的方式调用。//数组的角标（或索引从0开始的，到数组的长度-1结束。names[0] = &quot;王铭&quot;;names[1] = &quot;王赫&quot;;names[2] = &quot;张学良&quot;;names[3] = &quot;孙居龙&quot;;names[4] = &quot;王宏志&quot;;//charAt(0)\n\n3.2.3 数组的属性//数组的属性：lengthSystem.out.println(names.length);//5System.out.println(ids.length);\n\n说明：数组一旦初始化，其长度就是确定的。arr.length数组长度一旦确定，就不可修改。\n3.2.4 一维数组的遍历for(int i = 0;i &lt; arrayNames.length;i++)&#123;\tSystem.out.println(arrayNames[i]);&#125;\n\n3.2.5 一维数组元素的默认初始化值\n数组元素是整型：0\n数组元素是浮点型：0.0\n数组元素是char型：0或’\\u0000’，而非’0’\n数组元素是boolean型：false\n数组元素是引用数据类型：null\n\n3.2.6 一维数组的内存解析\nint[] arr = new int[]&#123;1,2,3&#125;;  String[] arr1 = new String[4];  arr1[1] = “刘德华”;arr1[2] = “张学友”;  arr1 = new String[3];  sysout(arr1[1]);//null\n\n\n/*从键盘读入学生成绩，找出最高分，  并输出学生成绩等级。成绩&gt;=最高分-10 等级为’A’成绩&gt;=最高分-20 等级为’B’成绩&gt;=最高分-30 等级为’C’其余 等级为’D’*/import java.util.Scanner;public class ArrayDemo &#123;    public static void main(String[] args) &#123;        //使用Scanner读取学生人数        Scanner input = new Scanner(System.in);        System.out.print(&quot;请输入学生人数：&quot;);        int studentCount = input.nextInt();        //创建数组        double[] studentArray = new double[studentCount];        //给数组赋值        double maxScore = 0;        for (int i = 0; i &lt; studentCount; i++) &#123;            System.out.print(&quot;请输入第&quot; + (i + 1) + &quot;个学生的成绩：&quot;);            studentArray[i] = input.nextDouble();            //获取数组里的最大值            if (maxScore &lt;= studentArray[i]) &#123;                maxScore = studentArray[i];            &#125;        &#125;        System.out.println(&quot;最高分是：&quot; + maxScore);        //输出数组里的成绩        for (int i = 0; i &lt; studentArray.length; i++) &#123;            System.out.println(studentArray[i]);        &#125;        //输出学生成绩和等级        for(int i = 0; i &lt; studentArray.length; i++)&#123;            if(studentArray[i] &gt;= (maxScore-10))&#123;                System.out.println(&quot;学生&quot;+ (i+1) + &quot;的成绩是：&quot;+ studentArray[i] + &quot;等级是&quot; + &quot;A&quot;);            &#125;else if(studentArray[i] &gt;= (maxScore-20))&#123;                System.out.println(&quot;学生&quot;+ (i+1) + &quot;的成绩是：&quot;+ studentArray[i] + &quot;等级是&quot; + &quot;B&quot;);            &#125;else if(studentArray[i] &gt;= (maxScore-30))&#123;                System.out.println(&quot;学生&quot;+ (i+1) + &quot;的成绩是：&quot;+ studentArray[i] + &quot;等级是&quot; + &quot;C&quot;);            &#125;else&#123;                System.out.println(&quot;学生&quot;+ (i+1) + &quot;的成绩是：&quot;+ studentArray[i] + &quot;等级是&quot; + &quot;D&quot;);            &#125;        &#125;    &#125;&#125;\n\n\n\n3.3 多维数组的使用\nJava 语言里提供了支持多维数组的语法。\n\n如果说可以把一维数组当成几何中的线性图形，那么二维数组就相当于是一个表格，像下图Excel中的表格一样。\n\n\n\n3.3.1 如何理解二维数组\n数组属于引用数据类型\n数组的元素也可以是引用数据类型\n一个一维数组A的元素如果还是一个一维数组类型的，则，此数组A称为二维数组。\n\n3.3.2 二维数组的声明与初始化//正确的方式：int[] arr = new int[]&#123;1,2,3&#125;;//一维数组//静态初始化int[][] arr1 = new int[][]&#123;&#123;1,2,3&#125;,&#123;4,5&#125;,&#123;6,7,8&#125;&#125;;//动态初始化1String[][] arr2 = new String[3][2];//动态初始化2String[][] arr3 = new String[3][];//也是正确的写法：int[] arr4[] = new int[][]&#123;&#123;1,2,3&#125;,&#123;4,5,9,10&#125;,&#123;6,7,8&#125;&#125;;int[] arr5[] = &#123;&#123;1,2,3&#125;,&#123;4,5&#125;,&#123;6,7,8&#125;&#125;;//类型推断\n\n//错误的方式：//String[][] arr4 = new String[][4];//String[4][3] arr5 = new String[][];//int[][] arr6 = new int[4][3]&#123;&#123;1,2,3&#125;,&#123;4,5&#125;,&#123;6,7,8&#125;&#125;;\n\n3.3.3 如何调用二维数组元素System.out.println(arr1[0][1]);//2System.out.println(arr2[1][1]);//nullarr3[1] = new String[4];System.out.println(arr3[1][0]);System.out.println(arr3[0]);\n\n3.3.4 二维数组的属性System.out.println(arr4.length);//3System.out.println(arr4[0].length);//3System.out.println(arr4[1].length);//4\n\n3.3.5 遍历二维数组元素for(int i = 0; i &lt; arr4.length; i++)&#123;    for(int j = 0; j &lt; arr4[i].length;j++)&#123;        System.out.print(arr4[i][j] + &quot;  &quot;);    &#125;    System.out.println();&#125;\n\n3.3.6 二维数组元素的默认初始化值规定：二维数组分为外层数组的元素，内层数组的元素\tint[][] arr = new int[4][3];\t外层元素：arr[0],arr[1]等\t内层元素：arr[0][0],arr[1][2]等\t⑤ 数组元素的默认初始化值 \t针对于初始化方式一：比如：int[][] arr = new int[4][3];\t\t外层元素的初始化值为：地址值\t\t内层元素的初始化值为：与一维数组初始化情况相同\t针对于初始化方式二：比如：int[][] arr = new int[4][];\t\t外层元素的初始化值为：null\t\t内层元素的初始化值为：不能调用，否则报错。\n\n3.3.7 二维数组的内存结构\n3.3.8 练习\n\n\npublic class ArrayExer1 &#123;    public static void main(String[] args) &#123;        int[][] arr = new int[][]&#123;&#123;3, 5, 8&#125;, &#123;12, 9&#125;, &#123;7, 0, 6, 4&#125;&#125;;        int sum = 0;        for (int i = 0; i &lt; arr.length; i++) &#123;            for (int j = 0; j &lt; arr[i].length; j++)&#123;                sum += arr[i][j];            &#125;        &#125;        System.out.println(sum);    &#125;&#125;\n\n\n\n\n使用二维数组打印一个 10 行杨辉三角。\npublic class YangHuiTest &#123;    public static void main(String[] args) &#123;        /*        * 【提示】        第一行有 1 个元素, 第 n 行有 n 个元素        每一行的第一个元素和最后一个元素都是 1        从第三行开始, 对于非第一个元素和最后一个元        素的元素。即：        yanghui[i][j] = yanghui[i-1][j-1] + yanghui[i-1][j];        */        //创建一个数组        int[][] yangHui = new int[10][];        //在数组里在创建一个数组        for (int i = 0; i &lt; yangHui.length; i++) &#123;            //第一行有 1 个元素, 第 n 行有 n 个元素            yangHui[i] = new int[i + 1];            for (int j = 0; j &lt; yangHui[i].length; j++) &#123;                //每一行的第一个元素和最后一个元素都是 1                if (j == 0 || j == i) &#123;                    yangHui[i][j] = 1;                &#125; else &#123;                    //从第三行开始, 对于非第一个元素和最后一个元素                    yangHui[i][j] = yangHui[i - 1][j - 1] + yangHui[i - 1][j];                &#125;            &#125;        &#125;        for (int i = 1; i &lt; yangHui.length; i++) &#123;            for (int j = 1; j &lt; yangHui[i].length; j++) &#123;                System.out.print(yangHui[i][j] + &quot;\\t&quot;                   );            &#125;            System.out.println();        &#125;    &#125;&#125;\n\n\n面试题目\n\n1、创建一个长度为 6 的 int 型数组，要求取值为 1-30，同时元素值各不相同\n\nclass ArrayExer &#123;\tpublic static void main(String[] args) &#123;\t\t//方式一：//\t\tint[] arr = new int[6];//\t\tfor (int i = 0; i &lt; arr.length; i++) &#123;// [0,1) [0,30) [1,31)//\t\t\tarr[i] = (int) (Math.random() * 30) + 1;////\t\t\tboolean flag = false;//\t\t\twhile (true) &#123;//\t\t\t\tfor (int j = 0; j &lt; i; j++) &#123;//\t\t\t\t\tif (arr[i] == arr[j]) &#123;//\t\t\t\t\t\tflag = true;//\t\t\t\t\t\tbreak;//\t\t\t\t\t&#125;//\t\t\t\t&#125;//\t\t\t\tif (flag) &#123;//\t\t\t\t\tarr[i] = (int) (Math.random() * 30) + 1;//\t\t\t\t\tflag = false;//\t\t\t\t\tcontinue;//\t\t\t\t&#125;//\t\t\t\tbreak;//\t\t\t&#125;//\t\t&#125;////\t\tfor (int i = 0; i &lt; arr.length; i++) &#123;//\t\t\tSystem.out.println(arr[i]);//\t\t&#125;\t\t//方式二：\t\tint[] arr = new int[6];\t\tfor (int i = 0; i &lt; arr.length; i++) &#123;// [0,1) [0,30) [1,31)\t\t\tarr[i] = (int) (Math.random() * 30) + 1;\t\t\t\t\t\t\tfor (int j = 0; j &lt; i; j++) &#123;\t\t\t\t\tif (arr[i] == arr[j]) &#123;\t\t\t\t\t\ti--;\t\t\t\t\t\tbreak;\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t&#125;\t\tfor (int i = 0; i &lt; arr.length; i++) &#123;\t\t\tSystem.out.println(arr[i]);\t\t&#125;\t&#125;&#125;\n\n\n\n3.4 数组的常见算法\n数组元素的赋值(杨辉三角、回形数等)\n求数值型数组中元素的最大值、最小值、平均数、总和等\n数组的复制、反转、查找(线性查找、二分法查找)\n数组元素的排序算法\n\n3.4.1 数组元素的基本操作练习一\n/* * 算法的考察：求数值型数组中元素的最大值、最小值、平均数、总和等 *  * 定义一个 int 型的一维数组，包含 10 个元素，分别赋一些随机整数， * 然后求出所有元素的最大值，最小值，和值，平均值，并输出出来。 * 要求：所有随机数都是两位数。 *  * [10,99] * 公式：(int)(Math.random() * (99 - 10 + 1) + 10) */public class ArrayTest1 &#123;\tpublic static void main(String[] args) &#123;\t\tint[] arr = new int[10];\t\t//数组赋值\t\tfor(int i = 0;i &lt;arr.length;i++)&#123;\t\t\tarr[i] = (int)(Math.random() * (99 - 10 + 1) + 10);\t\t&#125;\t\t\t\t//遍历\t\tfor(int i =0;i &lt; arr.length;i++)&#123;\t\t\tSystem.out.print(arr[i] + &quot; &quot;);\t\t&#125;\t\tSystem.out.println();\t\t\t\t//求数组元素的最大值\t\tint maxValue = arr[0];\t\tfor(int i = 1;i &lt;arr.length;i++)&#123;\t\t\tif(maxValue &lt; arr[i])&#123;\t\t\t\tmaxValue = arr[i];\t\t\t&#125;\t\t&#125;\t\tSystem.out.println(&quot;最大值：&quot; + maxValue);\t\t\t\t//求数组元素的最小值\t\tint minValue = arr[0];\t\tfor(int i = 1;i &lt;arr.length;i++)&#123;\t\t\tif(minValue &gt; arr[i])&#123;\t\t\t\tminValue = arr[i];\t\t\t&#125;\t\t&#125;\t\tSystem.out.println(&quot;最小值：&quot; + minValue);\t\t\t\t//求数组元素的总和\t\tint sum = 0;\t\tfor(int i = 1;i &lt;arr.length;i++)&#123;\t\t\tsum += arr[i];\t\t&#125;\t\tSystem.out.println(&quot;总和：&quot; + sum);\t\t\t\t//求数组元素的平均数\t\tdouble avgVales = sum / arr.length;\t\tSystem.out.println(&quot;平均数：&quot; + avgVales);\t\t\t&#125;&#125;\n\n练习二：\n/* * 使用简单数组 * (1)创建一个名为 ArrayTest 的类，在 main()方法中声明 array1 和 array2 两个变量，他们是 int[]类型的数组。 * (2)使用大括号&#123;&#125;，把 array1 初始化为 8 个素数：2,3,5,7,11,13,17,19。 * (3)显示 array1 的内容。 * (4)赋值 array2 变量等于 array1，修改 array2 中的偶索引元素，使其等于索引值(如 array[0]=0,array[2]=2)。打印出 array1。 */public class ArrayTest2 &#123;\tpublic static void main(String[] args) &#123;\t\t//声明 array1 和 array2 两个 int[]变量\t\tint[] array1,array2;\t\t//array1 初始化\t\tarray1 = new int[]&#123;2,3,5,7,11,13,17,19&#125;;\t\t\t\t//显示 array1 的内容==遍历。\t\tfor(int i = 0;i &lt; array1.length;i++)&#123;\t\t\tSystem.out.print(array1[i] + &quot;\\t&quot;);\t\t&#125;\t\t\t\t//赋值 array2 变量等于 array1        //不能称作数组的复制。\t\tarray2 = array1;\t\t\t\t//修改 array2 中的偶索引元素，使其等于索引值(如 array[0]=0,array[2]=2)。\t\tfor(int i = 0;i &lt; array2.length;i++)&#123;\t\t\tif(i % 2 == 0)&#123;\t\t\t\tarray2[i] = i;\t\t\t&#125;\t\t&#125;\t\tSystem.out.println();\t\t\t\t//打印出 array1。\t\tfor(int i = 0;i &lt; array1.length;i++)&#123;\t\t\tSystem.out.print(array1[i] + &quot;\\t&quot;);\t\t&#125;\t&#125;&#125;\n\n1. 思考：上述 array1 和 array2 是什么关系？\n//array1 和 array2 地址值相同，都指向了堆空间的唯一的一个数组实体。int[] array1,array2;array1 = new int[]&#123;2,3,5,7,11,13,17,19&#125;;array2 = array1;for(int i = 0;i &lt; array2.length;i++)&#123;\tif(i % 2 == 0)&#123;\t\tarray2[i] = i;\t&#125;&#125;\n\n\n2、拓展：修改题目，实现 array2 对 array1 数组的复制\nint[] array1,array2;array1 = new int[]&#123;2,3,5,7,11,13,17,19&#125;;//数组的复制array2 = new int[array1.length];for(int i = 0;i &lt; array2.length;i++)&#123;\tarray2[i] = array1[i];&#125;\n\n\n3.4.2 数组的复制、反转、查找\n复制、反转\npublic class ArrayTest1 &#123;    public static void main(String[] args) &#123;        //数组的复制、反转、查找(线性查找、二分法查找)        String[] array = new String[]&#123;&quot;DD&quot;, &quot;MM&quot;, &quot;GieGie&quot;, &quot;GG&quot;&#125;;        //复制        String[] array1 = new String[array.length];        for (int i = 0; i &lt; array1.length; i++) &#123;            array1[i] = array[i];        &#125;        //反转        /*        方式一：        for (int i = 0; i &lt; array.length/2; i++) &#123;            String temp = array[i];            array[i] = array[array.length - i - 1];            array[array.length - i - 1] = temp;        &#125;        方式二        for(int i = 0,j = array.length -1; i&lt;j;i++,j--)&#123;            String temp = array[i];            array[i] = array[j];            array[j] = temp;        &#125;        *///        String[] array3 = new String[array.length];//        for(int i = 0; i &lt; array3.length; i++)&#123;//            array3[i] = array[array.length -i - 1];//        &#125;//        array = array3;        //输出        for (int i = 0; i &lt; array.length; i++) &#123;            System.out.print(array[i] + &quot;\\t&quot;);        &#125;        System.out.println();        //查找        //线性查找        String dest = &quot;MM&quot;;        boolean isFlag = true;        for (int i = 0; i &lt; array.length; i++) &#123;            if (dest.equals(array[i])) &#123;                System.out.println(&quot;找到了指定元素，位置为：&quot; + i);                isFlag = false;                break;            &#125;        &#125;        if (isFlag) &#123;            System.out.println(&quot;没找到搜索内容&quot;);        &#125;    &#125;&#125;\n\n二分查找法\n\n\n\n      //二分查找法////前提：所要查找的数组必须有序      int[] numArray = new int[]&#123;-25, 20, 60, 85, 35, 24, 58, -78&#125;;      int dest1 = 0;      int head = 0;      int end = numArray.length - 1;      boolean  isFlag1 = true;      while (head &lt;= end) &#123;          int middle = (head + end) / 2;          if (dest1 == numArray[middle])&#123;              System.out.println(&quot;找到了指定元素，位置为：&quot; + middle);              isFlag1 = false;              break;          &#125;else if (numArray[middle] &gt; dest1)&#123;              end = middle -1;          &#125;else&#123;              head = middle + 1;          &#125;      &#125;      if(isFlag1)&#123;          System.out.println(&quot;没找到搜索内容&quot;);      &#125;\n\n3.4.3 数组的排序算法\n选择排序\n\n直接选择排序、堆排序\n\n\n交换排序\n\n冒泡排序、快速排序\n\n\n插入排序\n直接插入排序、折半插入排序、Shell排序\n\n归并排序\n\n桶式排序\n\n基数排序\n\n\n理解：\n\n衡量排序算法的优劣：时间复杂度、空间复杂度、稳定性\n排序的分类：内部排序 与 外部排序（需要借助于磁盘）\n\n冒泡排序\npublic class BubbleSortTest &#123;    public static void main(String[] args) &#123;        //冒泡排序的实现        int[] numArrays = new int[]&#123;12, -24, 45, 56, 78, -85, 84, -98&#125;;        for (int i = 0; i &lt; numArrays.length; i++) &#123;            System.out.print(numArrays[i] + &quot;\\t&quot;);        &#125;        System.out.println();        //执行多少轮        for (int i = 0; i &lt; numArrays.length - 1; i++) &#123;            for (int j = 0; j &lt; numArrays.length - 1 - i; j++) &#123;                if (numArrays[j] &gt; numArrays[j + 1]) &#123;                    int temp = numArrays[j];                    numArrays[j] = numArrays[j + 1];                    numArrays[j + 1] = temp;                &#125;            &#125;        &#125;        System.out.println();        for (int i = 0; i &lt; numArrays.length; i++) &#123;            System.out.print(numArrays[i] + &quot;\\t&quot;);        &#125;    &#125;&#125;\n\n3.5 Arrays 工具类的使用\njava.util.Arrays类即为操作数组的工具类，包含了用来操作数组（比如排序和搜索）的各种方法。\n\n\n\n\n1\nboolean  equals(int[] a,int[] b)\n判断两个数组是否相等。\n\n\n\n2\nString  toString(int[] a)\n输出数组信息。\n\n\n3\nvoid  fill(int[] a,int  val)\n将指定值填充到数组之中。\n\n\n4\nvoid  sort(int[]  a)\n对数组进行排序。\n\n\n5\nint binarySearch(int[]  a,int  key)\n对排序后的数组进行二分法检索指定的值。\n\n\npublic class ArraysTest &#123;    public static void main(String[] args) &#123;        //java.util.arrays:操作数组的工具类，里面定义了很多操作数组的方法        //boolean equals(int[] a,int[] b) 判断两个数组是否相等。        int[] arr1 = new int[]&#123;1, 2, 3, 4&#125;;        int[] arr2 = new int[]&#123;1, 2, 5, 4&#125;;        boolean isEquals = Arrays.equals(arr1, arr2);        System.out.println(isEquals);        //String toString(int[] a) 输出数组信息。        System.out.println(Arrays.toString(arr1));        //void fill(int[] a,int val) 将指定值填充到数组之中。        Arrays.fill(arr1,25);        System.out.println(Arrays.toString(arr1));        //void sort(int[] a) 对数组进行排序。        Arrays.sort(arr2);        System.out.println(Arrays.toString(arr2));        //int binarySearch(int[] a,int key) 对排序后的数组进行二分法检索指定的值。        int[] arr3 = new int[]&#123;-52,-5,1, 2,52,68,78,105,250,312&#125;;        int index = Arrays.binarySearch(arr3, 52);        System.out.println(index);    &#125;&#125;\n\n3.6 数组使用中的常见异常/* * 数组中的常见异常： * 1.数组角标越界的异常:ArrayIndexOutOfBoundsException *  * 2.空指针异常:NullPointerException *  */public class ArrayExceptionTest &#123;\tpublic static void main(String[] args) &#123;\t\t\t\t//1.数组角标越界的异常:ArrayIndexOutOfBoundsException\t\tint[] arr = new int[]&#123;1,2,3,4,5,6&#125;;\t\t\t\t//错误1：//\t\tfor(int i = 0;i &lt;= arr.length;i++)&#123;//\t\t\tSystem.out.println(arr[i]);//\t\t&#125;\t\t\t\t//错误2：//\t\tSystem.out.println(arr[-2]);\t\t\t\t//错误3//\t\tSystem.out.println(&quot;hello&quot;);\t\t\t\t//2.空指针异常:NullPointerException\t\t//情况一://\t\tint[] arr2= new int[]&#123;1,2,3&#125;;//\t\tarr2 = null;//\t\tSystem.out.println(arr2[0]);\t\t//情况二://\t\tint[][] arr2 = new int[4][];//\t\tSystem.out.println(arr2[0][0]);\t\t\t\t//情况三://\t\tString[] arr3 = new String[]&#123;&quot;AA&quot;,&quot;QQ&quot;,&quot;YY&quot;,&quot;XX&quot;,&quot;TT&quot;,&quot;KK&quot;&#125;;//\t\tarr3[0] = null;//\t\tSystem.out.println(arr3[0].toString());\t\t\t&#125;&#125;\n\n4.面向对象编程(上)4.1 面向过程和面向对象何谓 “面向对象” 的编程想？？\n首先解释一下 “思想” 。先问你个问题：你想做个怎样的人？可能你会回答：我想做个好人，孝敬父母，尊重长辈，关爱亲朋……你看，这就是思想。这是你做人的思想，或者说，是你做人的原则。 做人有做人的原则，编程也有编程的原则。这些编程的原则呢，就 是编程思想。\n\n面向过程(POP) 与面向对象(OOP)\n\n\n面向对象：Object Oriented Programming\n面向过程：Procedure Oriented Programming\n\n一、面向对象学习的三条主线： 1.Java类及类的成员：属性、方法、构造器；代码块、内部类  2.面向对象的大特征：封装性、继承性、多态性、(抽象性)  3.其它关键字：this、super、static、final、abstract、interface、pac    kage、import等  * “大处着眼，小处着手”二、人把大象装进冰箱（面向对象举例） 面向过程：    强调的是功能行为，以函数为最小单位，考虑怎么做。    ① 打开冰箱    ② 把大象装进冰箱    ③ 把冰箱门关住      面向对象：    强调具备了功能的对象，以类/对象为最小单位，考虑谁来做。     人&#123;    打开(冰箱)&#123;        冰箱.开门();    &#125;    操作(大象)&#123;        大象.进入(冰箱);    &#125;    关闭(冰箱)&#123;        冰箱.关门();    &#125;&#125;冰箱&#123;    开门()&#123;            &#125;    关门()&#123;            &#125;&#125;大象&#123;   进入(冰箱)&#123;         &#125;  &#125;\n\n\n​\t面向对象的思想概述\n\n\n过程的执行者转化成了面向对象的指挥者\n过程的执行者转化成了面向对象的指挥者：\n根据问题需要，选择问题所针对的现实世界中的实体。\n从实体中寻找解决问题相关的属性和功能，这些属性和功能就形成了概念世界中的类。\n把抽象的实体用计算机语言进行描述，形成计算机世界中类的定义。即借助某种程序语言，把类构造成计算机能够识别和处理的数据结构。\n将类实例化成计算机世界中的对象。对象是计算机世界中解决问题的最终工具。\n\n\n\n4.2 类和对象4.2.1 Java类及类的成员现实世界的生物体，大到鲸鱼，小到蚂蚁，都是由最基本的细胞构成的。同理，Java 代码世界是由诸多个不同功能的类构成的。\n现实生物世界中的细胞又是由什么构成的呢？细胞核、细胞质、… 那么，Java 中用类 class 来描述事物也是如此。常见的类的成员有：\n\n属性：对应类中的成员变量\n行为：对应类中的成员方法\n\n\n4.2.2 类与对象的创建及使用/*一、设计类、其实就是设计类的成员\tField = 属性 = 成员变量 = 域、字段\tMethod = (成员)方法 = 函数     创建类 = 类的实例化 = 实例化类    二.类和对象的使用(面向对象思想落地的实现)1. 创建类，设计类的成员2. 创建类的对象3. 通过“对象.属性”或“对象.方法”调用对象的结构三、如果创建类一个类的多个对象，则每个对象都独立的拥有一套类的属性。(非 static 的)意味着:如果我们修改一个对象的属性 a，则不影响另外一个对象属性 a 的值。*///测试类public class PersonTest&#123;  \tpublic static void main(String[] args) &#123;\t\t//2.创建 Person 类的对象\t\t//创建对象语法：类名对象名= new 类名();\t\tPerson p1 = new Person();\t\t\t\t//调用类的结构：属性、方法\t\t//调用属性:“对象.属性”\t\tp1.name = &quot;Tom&quot;;\t\tp1.age = 25;\t\tp1.isMale = true;\t\tSystem.out.println(p1.name);\t\t\t\t//调用方法:“对象.方法”\t\tp1.eat();\t\tp1.sleep();\t\tp1.talk(&quot;chinese&quot;);\t\t//**********************\t\tPerson p2 = new Person();\t\tSystem.out.println(p2.name); //null\t\tSystem.out.println(p2.isMale);\t\t//**********************\t\t//将 p1 变量保存的对象地址值赋给 p3,导致 p1 和 p3 指向了堆空间中的一个对象实体。\t\tPerson p3 = p1;\t\tSystem.out.println(p3.name);\t\t\t\tp3.age = 10;\t\tSystem.out.println(p1.age); //10\t&#125;  &#125;/* * 类的语法格式： * 修饰符 class 类名&#123; * \t\t属性声明; * \t\t方法声明; * &#125; * 说明：修饰符 public：类可以被任意访问类的正文要用&#123;  &#125;括起来 *///创建类，设计类的成员class Person&#123;    //属性：对应类中的成员变量：  \tString name;\tint age;\tboolean isMale;        //方法：对应类中的成员方法    \tpublic void eat()&#123;\t\tSystem.out.println(&quot;吃饭&quot;);\t&#125;\t\tpublic void sleep()&#123;\t\tSystem.out.println(&quot;睡觉&quot;);\t&#125;\t\tpublic void talk(String language)&#123;\t\tSystem.out.println(&quot;人可以说话，使用的是：&quot; +language);\t&#125;&#125;\n\n4.2.3 对象的创建和使用：内存解析\n\n堆（Heap），此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在 Java 虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配。\n通常所说的栈（Stack），是指虚拟机栈。虚拟机栈用于存储局部变量等。局部变量表存放了编译期可知长度的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不等同于对象本身，是对象在堆内存的首地址）。方法执行完，自动释放\n方法区（MethodArea），用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。\n\n\n1、案例 1\n\nPerson p1= newPerson();p1.name = &quot;Tom&quot;;p1.isMale = true;Person p2 = new Person();sysout(p2.name);//nullPerson p3 = p1;p3.age = 10;\n\n\n\n2、案例 2\n\nPerson p1= newPerson();p1.name = &quot;胡利民&quot;;p1.age = 23;Person p2 = new Person();p2.age = 10;\n\n\n4.2.4 类的成员之一：属性/*类中属性的使用属性(成员变量)\tvs\t局部变量1.相同点:\t1.1 定义变量的格式:数据类型 变量名 = 变量值\t1.2 先声明，后使用\t1.3 变量都有其对应的作用域2.不同点:\t2.1 在类中声明的位置不同\t属性:直接定义在类的一对&#123;&#125;内 \t局部变量:声明在方法内、方法形参、构造器形参、构造器内部的变量 \t2.2 关于权限修饰符的不同 \t属性:可以在声明属性时，指明其权限，使用权限修饰符。 \t\t常用的权限修饰符:private、public、缺省、protected \t\t目前声明属性时，都使用缺省即可。 \t局部变量:不可以使用权限修饰符。 \t \t2.3 默认初始化值的情况: \t属性:类的属性，根据其类型，都有默认初始化值。 \t\t整型(byte、short、int、long):0 \t\t浮点型(float、double):0.0 \t\t字符型(char):0(或‘\\u0000’) \t\t布尔型(boolean):false \t\t \t\t引用数据类型(类、数组、接口):null \t\t \t局部变量:没有默认初始化值 \t\t意味着:在调用局部变量之前，一定要显式赋值。        特别地:形参在调用时,赋值即可。            2.4 在内存中加载的位置，亦各不相同。    \t属性:加载到堆空间中(非 static)    \t局部变量:加载到栈空间     * */public class UserTest&#123;   \tpublic static void main(String[] args) &#123;\t\tUser u1 = new User();\t\tSystem.out.println(u1.name);\t\tSystem.out.println(u1.age);\t\tSystem.out.println(u1.isMale);\t\t\t\tu1.talk(&quot;日语&quot;);\t&#125; &#125;class User&#123;   \t//属性(或成员变量)\tString name;\t//不加 private 即为缺省\tpublic int age;\t//不加 public 即为缺省\tboolean isMale;        public void talk(tring language)&#123;//language:形参，也是局部变量       System.out.println(&quot;我们使用&quot; + language + &quot;进行交流。&quot;);     &#125;   public void eat()&#123;     String food = &quot;石头饼&quot;;\t//石头饼:局部变量     System.out.println(&quot;北方人喜欢吃:&quot; + food);     &#125; &#125;\n\n\n1、练习1\n\n/*编写教师类和学生类，并通过测试类创建对象进行测试Student类属性:name:String age:int major:String interests:String方法:say() 返回学生的个人信息Teacher类属性:name:String age:int teachAge:int course:String方法:say() 输出教师的个人信息*/public class School &#123;\tpublic static void main(String[] args) &#123;\t\tStudent stu = new Student();        stu.name = &quot;张三&quot;;        stu.age = 20;\t\t\t\tTeacher tea = new Teacher();\t\ttea.name = &quot;李四&quot;;        tea.age = 18;                tea.say(stu.name,stu.age);        stu.say(tea.name, tea.age);\t&#125;\t&#125;class public class School &#123;\tpublic static void main(String[] args) &#123;\t\tStudent stu = new Student();        stu.name = &quot;小明&quot;;        stu.age = 16;\t\t\t\tTeacher tea = new Teacher();\t\ttea.name = &quot;王老师&quot;;        tea.age = 27;                tea.say(stu.name,stu.age);        stu.say(tea.name, tea.age);\t&#125;\t&#125;class Teacher&#123;\tString name;\tint age;\tString teachAge;\tString course;\t\tvoid say(String name, int age)&#123;\t\tSystem.out.println(&quot;这个老师是：&quot;+name+&quot;年龄是：&quot;+age);\t&#125;&#125;\n\n4.2.5 类的成员之二：方法\n类中方法的声明和使用\n\n/*类中方法的声明和使用方法：描述类应该具有的功能。比如：Math类：sqrt()\\random() \\...\tScanner类：nextXxx() ...\tArrays类：sort() \\ binarySearch() \\ toString() \\ equals() \\ ...\t1.举例：public void eat()&#123;&#125;public void sleep(int hour)&#123;&#125;public String getName()&#123;&#125;public String getNation(String nation)&#123;&#125;2. 方法的声明：权限修饰符  返回值类型  方法名(形参列表)&#123;\t\t方法体&#125;\t 注意：static、final、abstract 来修饰的方法，后面再讲。3.说明：\t3.1 关于权限修饰符：默认方法的权限修饰符先都使用public\t\tJava规定的4种权限修饰符：private、public、缺省、protected  --&gt;封装性再细说\t3.2 返回值类型： 有返回值  vs 没有返回值\t3.2.1  如果方法有返回值，则必须在方法声明时，指定返回值的类型。同时，方法中，需要使用\t\t   return关键字来返回指定类型的变量或常量：“return数据”。\t\t   如果方法没有返回值，则方法声明时，使用void来表示。通常，没有返回值的方法中，就不需要\t\t   使用return.但是，如果使用的话，只能“return;”表示结束此方法的意思。\t3.2.2 我们定义方法该不该有返回值？\t\t① 题目要求\t\t② 凭经验：具体问题具体分析\t\t\t3.3 方法名：属于标识符，遵循标识符的规则和规范，“见名知意.    3.4 形参列表:方法名可以声明0个、1个，或多个形参。    \t3.4.1 格式:数据类型1 形参1，数据类型2 形参2,...    \t    \t3.4.2 我们定义方法时，该不该定义形参？    \t\t① 题目要求    \t\t② 凭经验，具体问题具体分析.    \t3.5 方法体:方法功能的体现。4. return关键字的使用：\t1.使用范围:使用在方法体中\t2.作业:① 结束方法\t\t② 针对于有返回值类型的方法，使用&quot;return 数据&quot;方法返回所要的数据。\t3.注意点:return关键字后不可声明执行语句。\t4.方法的使用中，可以调用当前类的属性或方法。\t5.特殊的:方法A中又调用了方法A:递归方法。\t6.方法中不能定义其他方法。*/public class CustomerTest &#123;\tpublic static void main(String[] args) &#123;\t\t\t\tCustomer cust1 = new Customer();\t\t\t\tcust1.eat();\t\t\t\t//测试形参是否需要设置的问题        //int[] arr = new int[]&#123;3,4,5,2,5&#125;;\t\t//cust1.sort();\t\t\t\tcust1.sleep(8);\t\t\t&#125;&#125;//客户类class Customer&#123;\t\t//属性\tString name;\tint age;\tboolean isMale;\t\t//方法\tpublic void eat()&#123;\t\tSystem.out.println(&quot;客户吃饭&quot;);\t\treturn;\t\t//return后不可以声明表达式//\t\tSystem.out.println(&quot;hello&quot;);\t&#125;    \tpublic void sleep(int hour)&#123;\t\tSystem.out.println(&quot;休息了&quot; + hour + &quot;个小时&quot;);\t\t\t\teat();//\t\tsleep(10);\t&#125;\t\tpublic String getName()&#123;\t\t\t\tif(age &gt; 18)&#123;\t\t\treturn name;\t\t\t\t\t&#125;else&#123;\t\t\treturn &quot;Tom&quot;;\t\t&#125;\t&#125;   \tpublic String getNation(String nation)&#123;\t\tString info = &quot;我的国籍是：&quot; + nation;\t\treturn info;\t&#125;/*\t体会形参是否需要设置的问题\tpublic void sort(int[] arr)&#123;\t\t&#125;\tpublic void sort()&#123;\t\tint[] arr = new int[]&#123;3,4,5,2,5,63,2,5&#125;;\t\t//。。。。\t&#125;\t\tpublic void info()&#123;\t\t//错误的\t\tpublic void swim()&#123;\t\t\t\t\t&#125;\t\t\t&#125;&#125;*/\n\n\n​\t练习1\n\n\npublic class PersonTest &#123;    public static void main(String[] args) &#123;        Person p1 = new Person();        p1.name = &quot;John&quot;;        p1.age = 15;        p1.sex = &quot;男的&quot;;        p1.study();        int ages = p1.showAge();        System.out.println(p1.name +  &quot;的年龄是：&quot; + ages);        p1.addAge(5);        ages = p1.showAge();        System.out.println(p1.name +  &quot;的年龄是：&quot; + ages);        Person p2 = new Person();        p2.name = &quot;Jack&quot;;        p2.age = 20;        p2.sex = &quot;女的&quot;;        p2.study();        System.out.println(p2.name + &quot;年龄：&quot; + p2.age);        p2.addAge(5);        System.out.println(p2.name + &quot;年龄：&quot; + p2.age);        System.out.println(p2.sex);    &#125;&#125;class Person &#123;    String name;    int age;    String sex;    public void study() &#123;        System.out.println(name + &quot; is studying&quot;);    &#125;    public int showAge() &#123;        return age;    &#125;    public void addAge(int add)&#123;        age += add;    &#125;&#125;\n\n\n​\t练习2\n\n\n//测试类public class CircleTest &#123;\tpublic static void main(String[] args) &#123;\t\tCircle c1 = new Circle();\t\t\t\tc1.radius = 2.1;\t\t\t\t//对应方式一://\t\tdouble area = c1.findArea();//\t\tSystem.out.println(area);\t\t\t\t//对应方式二:\t\tc1.findArea();\t\t//错误的调用\t\tdouble area = c1.findArea(3.4);\t\tSystem.out.println(area);\t&#125;&#125;//圆:3.14*r*rclass Circle&#123;\t//属性\tdouble radius;\t\t//圆的面积方法\t//方法1：//\tpublic double findArea()&#123;//\t\tdouble area = 3.14 * radius * radius;//\t\treturn area;//\t&#125;\t\t//方法2：\tpublic void findArea()&#123;\t\tdouble area = Math.PI * radius * radius;\t\tSystem.out.println(&quot;面积为:&quot; + area);\t&#125;\t//错误情况:\tpublic double findArea(Double r)&#123;\t\tdouble area = 3.14 * r * r;\t\treturn area;\t&#125;&#125;\n\n\n​\t练习3\n\n/* * 3.1 编写程序，声明一个method方法，在方法中打印一个10*8的*型矩形，在main方法中调用该方法。 * 3.2修改上一个程序，在method方法中，除打印一个10*8的*型矩形外，再计算该矩形的面积， * 并将其作为方法返回值。在main方法中调用该方法，接收返回的面积值并打印。 *  * 3.3 修改上一个程序，在method方法提供m和n两个参数，方法中打印一个m*n的*型矩形， * 并计算该矩形的面积，将其作为方法返回值。在main方法中调用该方法，接收返回的面积值并打印。 *  */public class MethodTest &#123;    public static void main(String[] args) &#123;        Method m1 = new Method();        int area = m1.printSquare(10,10);        System.out.println(&quot;面积是： &quot; + area);    &#125;&#125;class Method &#123;    int m;    int n;    public int printSquare(int m, int n) &#123;        for (int i = 0; i &lt; m; i++) &#123;            for (int j = 0; j &lt; n; j++) &#123;                System.out.print(&quot;*&quot;);            &#125;            System.out.println();        &#125;        return m * n;    &#125;&#125;\n\n\n​\t练习4\n\n/*定义类Student，包含三个属性：学号number(int)，年级state(int)，成绩score(int)。 创建20个学生对象，学号为1到20，年级和成绩都由随机数确定。 问题一：打印出3年级(state值为3）的学生信息。问题二：使用冒泡排序按学生成绩排序，并遍历所有学生信息提示：生成随机数：Math.random()，返回值类型double;四舍五入取整：Math.round(double d)，返回值类型long。*/public class StudentTest &#123;    public static void main(String[] args) &#123;        //这是存放二十个学生对象的数组？        Student[] statuses = new Student[20];        for (int i = 0; i &lt; statuses.length; i++) &#123;            //创建学生对象            statuses[i] = new Student();            //给学生学号对象赋值            statuses[i].number = (i + 1);            //给学生班级对象赋值 1-6            statuses[i].state = (int) (Math.random() * (6) + 1);            //给学生对象的成绩赋值            statuses[i].score = (int) (Math.random() * (100 + 1));        &#125;        Student s1 = new Student();        //遍历Student数组        s1.StudentInfo(statuses);        System.out.println(&quot;**********************&quot;);        //打印指定年级学生的信息        s1.SearchStudent(statuses, 3);        System.out.println(&quot;**********************&quot;);        //冒泡排序学的成绩        s1.SortStudent(statuses);        s1.StudentInfo(statuses);    &#125;&#125;class Student &#123;    int number;    int state;    int score;    /**     * @Description 显示所有学生     */    public void StudentInfo(Student[] statuses) &#123;        for (int i = 0; i &lt; statuses.length; i++) &#123;            System.out.println(statuses[i].info());;        &#125;    &#125;    /**     * @Description 冒泡排序学生成绩     */    public void SortStudent(Student[] statuses)&#123;        for (int i = 0; i &lt; statuses.length-1; i++) &#123;            for (int j = 0; j &lt; statuses.length-1-i; j++) &#123;                if (statuses[j].score &gt; statuses[j+1].score)&#123;                    Student temp = statuses[j];                    statuses[j] = statuses[j + 1];                    statuses[j+1] = temp;                &#125;            &#125;        &#125;    &#125;    /**     * @Description 查找指定年级学生     * @param statuses     * @param num 要查找的年级     */    public void SearchStudent(Student[] statuses, int num) &#123;        for (int i = 0; i &lt; statuses.length; i++) &#123;            if (statuses[i].state == num) &#123;                System.out.println(statuses[i].info());            &#125;        &#125;    &#125;    /**     * @Description 显示学生的参数的方法     */    public String info() &#123;        return &quot;学号：&quot; + number + &quot;\\t班级：&quot; + state + &quot;\\t成绩：&quot; + score;    &#125;&#125;\n\n","tags":["学习笔记"]}]